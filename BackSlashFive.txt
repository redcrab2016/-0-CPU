Functional processor (not a system processor : no interruption/signal handling, no processor internal control instruction )
16 registers 16 bits (word)
8 execution conditions
64 Ki word addresses
16 bits per instruction ( one word per instruction)
Can be implemented for same address space for program, data and I/O
or for seperated program and data, I/O address space (no mix betwen data and program, not possible to have self modified program)

registers: - R0 to R15 (designated by 4 bits)
R0  : 0000 : general most versatile (every instruction can use R0)
R1  : 0001 : general
R2  : 0010 : general
R3  : 0011 : general
R4  : 0100 : general
R5  : 0101 : general
R6  : 0110 : general
R7  : 0111 : general
R8  : 1000 : general
R9  : 1001 : general
R10 : 1010 : general
R11 : 1011 : general
R12 : 1100 : general
R13 : 1101 : general
R14 : 1110 :FL: 16 bits flags  -------- -----XZC, bit 0 and 1 are reserved for C carry and Zero flag respectively
R15 : 1111 :PC: Program address

flags R14:FL
   bit 0
   C : =1 if 
	addition has a carry
	substaction has a borrow
	last evacuated bit by shift left/right is 1
	=0 otherwise
   bit 1
     Z : After instruction execution if modified register/bit is equal to zero then Z=1, 0 otherwise
   bit 2
     X : custom flag to set/clear usable for conditional execution
   bit 3 to 15
     - : other general flags for program usage

Program counter R15:PC
   represent the address of the next natural instuction, not the address of current instruction in execution
   branching is done by a "mov R15, ..." , "add R15, ..."  or "sub R15 , ..." instruction
   branching with "not R15..." instruction is allowed
   if PC get overlapped (from FFFF to 0000) then the processor halt, then halting may be done by
	al nf mov R14, 0
	al nf sub R14, 1
	al nf mov R15, R14
	( keep general registers untouched, and at the end R14=FFFF and R15=0000)
   or
	al nf mov low  R0, 255
	al nf mov high R0, 255
	al nf mov R15, R0

   Therefore instruction at address FFFF can't be executed. (at instruction fetch, PC increment, set a carry causing a processor halt)
   so address FFFF can only be an address for data or I/O
   At processor reset time PC is set to 0 ( same for all other registers)
   It is possible to block (get stuck) the processor by the following instruction
	al nf sub R15, 1   ; the instruction is repeated endlessly

Instruction structure: 16 bits (65536 possible instruction execution: Each value get a valid meaning )
ccc f oooo yyyy xxxx  2 registers parameters
ccc f oooo iiii iiii  1 unisgned byte parameter
ccc f oooo siii iiii  1 signed byte parameter
ccc f oooo iiii xxxx  1 register and 1 quartet parameters
ccc f oooo oooo xxxx  1 register parameter
ccc f oooo oooo iiii  1 quartet parameter

ccc       is the 3 bits of instruction execution condition
f         is the bit of conditional flag modification by instruction execution
oooo      is the 4 bits instruction code
oooo oooo is the 8 bits instruction code
xxxx      is the 4 bits register index (Rx)
yyyy      is the 4 bits register index (Ry)
iiii      is the 4 bits of an immediate unsigned integer
iiii iiii is the 8 bits of an immediate unsigned integer
siii iiii is the 8 bits of an immediate signed integer

conditions: ccc
000	al      	Always executed.					No flag tested.
001	eq or zs	Equal.							Z==1
010	ne or zc	Not equal.						Z==0
011	cs or hs	Unsigned higher or same (or carry set).			C==1
100	cc or lo	Unsigned lower (or carry clear).			C==0
101     xs		custom bit set                                          X==1
110     xc              custom bit clear                                        X==0
111	no		never executed (NOP)					No flag tested

flag modified : f
if 0 then no flag is modified by the instruction, 1 flag(s) modified by the instruction
0	nf
1	fl

instruction: oooo / oooo oooo
raw mnemonic: 8 mnemonics
	mov, add, sub, and, or, not, shl, shr

instruction per mnemonic : 31 instructions
	mov (Z flag )
		mov Rx, 0
		mov low Rx, 0
		mov high Rx, 0
		mov Rx, Ry
		mov Rx, [Ry]
		mov [Rx], Ry
		mov low R0, imm8
		mov high R0, imm8
		mov low R0, low Rx
		mov high R0, low Rx
		mov low R0, high Rx
		mov high R0, high Rx
		mov C, Rx:imm4
		mov Rx:imm4, C
		mov Rx:imm4, 0
		mov Rx:imm4, 1

	add ( Z, C flags)
		add Rx, Ry
		add Rx, [Ry]
		add R0, imm4
		add Rx, 1
		add R15, simm8
	
	sub ( Z, C flags)
		sub Rx, Ry
		sub Rx, [Ry]
		sub R0, imm4
		sub Rx, 1

	shl ( Z, C flags)
		shl R0, imm4

	shr ( Z, C flags)
		shr R0, imm4
	
	and (Z flag)
		and R0, Rx

	or (Z flag)
		or R0, Rx
	
	not (Z flag)
		not Rx:imm4
		not Rx



Instruction encoding

=== Byte parameter (max 15 instr)
2 registers parameters 
ccc f 0000 yyyy xxxx
	mov Rx, Ry

ccc f 0001 yyyy xxxx
	mov [Rx], Ry

ccc f 0010 yyyy xxxx
	mov Rx, [Ry] 

ccc f 0011 yyyy xxxx
	add Rx, Ry

ccc f 0100 yyyy xxxx
	sub Rx, Ry

ccc f 0101 yyyy xxxx
	add Rx, [Ry]

ccc f 0110 yyyy xxxx
	sub Rx, [Ry]

1 unsigned/signed byte parameter 
ccc f 0111 iiii iiii
	mov low R0, imm8
ccc f 1000 iiii iiii
	mov high R0, imm8
ccc f 1001 siii iiii
	add R15, simm8

1 register and 1 quartet parameter
ccc f 1010 iiii xxxx
	mov C, Rx:imm4

ccc f 1011 iiii xxxx
	mov Rx:imm4, C

ccc f 1100 iiii xxxx
	mov Rx:imm4, 0

ccc f 1101 iiii xxxx
	mov Rx:imm4, 1

ccc f 1110 iiii xxxx
	not Rx:imm4

=== Quartet parameter (max 16 instr)
1 quartet
ccc f 1111 0000 iiii
	add R0, imm4

ccc f 1111 0001 iiii
	sub R0, imm4

ccc f 1111 0010 iiii
	shl R0, imm4

ccc f 1111 0011 iiii
	shr R0, imm4

1 register
ccc f 1111 0100 xxxx
	add Rx, 1

ccc f 1111 0101 xxxx
	sub Rx, 1

ccc f 1111 0110 xxxx
	mov low R0, low Rx

ccc f 1111 0111 xxxx
	mov low R0, high Rx

ccc f 1111 1000 xxxx
	mov high R0, low Rx

ccc f 1111 1001 xxxx
	mov high R0, high Rx

ccc f 1111 1010 xxxx
	mov low Rx, 0

ccc f 1111 1011 xxxx
	mov high Rx, 0

ccc f 1111 1100 xxxx
	mov Rx, 0

ccc f 1111 1101 xxxx
	not Rx

ccc f 1111 1110 xxxx
	and R0, Rx

ccc f 1111 1111 xxxx
	or  R0, Rx

Assembly micro program for missing register versatility (Rx with x != 0)
Example of missing versatility :
	  mov low R0, imm8 ; doable 
	  mov low R1, imm8 ; not doable by a single instruction

The two first lines of each micro progam below
	ccc nf add R15, 1 
	al  nf add R15, 3 
does exist only if ccc != al.

each micro program below do modify register R0 ( at end of each micro program R0 == Rx )

ccc f mov low Rx, imm8 
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov low R0, imm8
	al  nf mov Rx, R0

ccc f  mov high Rx, imm8
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov high R0, imm8
	al  nf mov Rx, R0

ccc f add Rx, imm4
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  add R0, imm4
	al  nf mov Rx, R0

ccc f sub Rx, imm4
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  sub R0, imm4
	al  nf mov Rx, R0


ccc f shl Rx, imm4
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  shl R0, imm4
	al  nf mov Rx, R0

ccc f shr Rx, imm4
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  shr R0, imm4
	al  nf mov Rx, R0

ccc f mov low Rx, low Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov low R0, low Ry
	al  nf mov Rx, R0

ccc f mov low Rx, high Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov low R0, high Ry
	al  nf mov Rx, R0

ccc f mov high Rx, low Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov high R0, low Ry
	al  nf mov Rx, R0

ccc f mov high Rx, high Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov high R0, high Ry
	al  nf mov Rx, R0

ccc f and Rx, Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  and R0, Ry
	al  nf mov Rx, R0

ccc f or  Rx, Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  or R0, Ry
	al  nf mov Rx, R0

Example programs
  Example #1
  Compute length of a null terminated string
  input : R1 address of the null terminated character string
  output: R2 length of the string  (R0 = 0, R3 = address of null terminated character)
  modified : R0, R3

	al nf mov R2, 0		; init found length R2 to 0
	al nf mov R3, R1        ; init start address R3 to R1
	al fl mov R0, [R3]      ; Z = [R3] == 0 ?
	zs nf add R15, 3	; if Z then end program
	al nf add R2, 1		; if not Z then increment found length (R2=R2+1)
	al nf add R3, 1		; if not Z then go to next character string address
	al nf sub R15, 5	; loop 

  Example #2
  Multiply 
  input : R1 , R2  (for R1 x R2)
  output: R3 , R4  (  R3 = low16( R1 x R2), R4 = high16( R1 x R2) )
  modified: R1, R2, R3, R4, R5
	
	al nf mov R3, 0
	al nf mov R4, 0  ; R3 = R4 = R5 = 0, R4:R3 32 bits result
	al nf mov R5, 0  ; R5 used for high 16 of R1 left shift R5:R1
;beginloop
	al fl mov, R2, R2
	zc nf add R15, 9  ; if R2 == 0 then go endmultiply

	al fl shr R2, 1
	cc nf add R15, 3  ; R2 >>= 1, if !C then go shift R1R5

	al fl add R3, R1 ; R3:R4 += R5:R1
	cs nf add R4, 1
	al nf add R4, R5

; shift R1R5
	al nf shl R5, 1
	al fl shl R1, 1  ; R5:R1 <<= 1
	cs nf add R5, 1

	al nf sub R15, 11  ; loop to beginloop
;endmultiply
