CISC 16 bits address, 8/16 bits data
little-endian data access and immediate encoding

1 or 2 bytes operator, 0, 1 or 2 bytes immediate data

REGISTERS

11 registers (4 times 16 bits general purpose registers overlaying the 8 times 8 bits general purpose registry)
16 bits stack, growing downward
dedicated purpose registers
	PC		: 16 bits : Reset at [0] (reset handler) : Program Counter , is where the CPU is fetching instruction and immediate data
	FL   		: 8(internal)/16 bits(when stored in stack) : Reset at 0x0000 : CPU status flags INVZC (interrupt, Negative, Overflow, Zero, Carry)
	SP		: 16 bits : Reset at 0x0400 (initialized to 0x0400)
general registers
	B7 W3(high)		
	B6 W3(low)
	B5 W2(high)
	B4 W2(low)
	B3 W1(high)
	B2 W1(low)
	B1 W0(high)
	B0 W0(low)

	Wx : 4 times 16 bits registers, 2 bits encoding (W0:00, W1:01, W2:10, W3:11)
	Rx : 8 times 8 bits registers, 3 bits encoding (B0:000, B1:001, B2:010, B3:011, B4:100, B5:101, B6:110, B7:111)

MEMORY MAP
	2^16 memory space, adressing 8bits byte
	address from 0x0000 to 0xFFFF
	Memory initialized by Hypervisor. 
	Memory map : RAM and I/O 
	0000 - 001F : interruption handler
		vector 0  : 0000 : Reset handler (contains address of bootstrap at RESET time ) / may be redefined by program execution (e.g system library)
		vector 1  : 0002 : Escape to CPU hypervisor ( it is not a address and is ignored, keep 0x0000. Only to be used with INT 1, instruction)
		vector 2  : 0004 : Hypervisor Event (handler of supervisor event)
		vector 3  : 0006 : System Timer (periodic interuption, by clock count)
		vector 4  : 0008 : byte input data event (Hypervisor data input event, meta and data at 0020, 0021)
		vector 5  : 000A : data block input data (Hypervisor data input event, metadata at 002A-002F)
		vector 6  : 000C : Division by Zero
		vector 7  : 000E : user defined
		vector 8  : 0010 : user defined
		vector 9  : 0012 : user defined
		vector 10 : 0014 : user defined
		vector 11 : 0016 : user defined
		vector 12 : 0018 : user defined
		vector 13 : 001A : user defined
		vector 14 : 001C : user defined
		vector 15 : 001E : user defined

	0020 - 002F : Timer/core I-O/Hypervisor event data exchange
		0020 : byte input data
		0021 : input data ready (==0 , 0020 is ready for a read operation, ==FF no input available, ==01 wait(about to come))
		0022 : byte output data
		0023 : output data ready (==0 , 0022 is ready for a write operation)
		0024 : byte secondary output data
		0025 : secondary output data ready (==0, 0024 is ready for write operation)
		0026 : Timer clock count low  (32 bits counters, set here from 0026 0029, the tick delay)
		0028 : Timer clock count high
		002A : data block input ready
		002C : data block input address
		002E : data block input length 
	
	0030 - 03FF : Default Stack(grow downward, SP initial value to 0400) / possible Data / possible Code		
	0400 - FEFF : Code / Data / possible stack
	FF00 - FFFF : I-O (256 I/O port)
INSTRUCTION SET (225)

Intruction memonic table code (8 bits byte : Horizontal MS4bits, Vertical LS4bits)
	0-	1-	2-	3-	4-	5-	6-	7-	8-	9-	A-	B-	C-	D-	E-	F-
-0	NOP	LEAW0	INT0	J_W0	JZ	LDBm0	LDWm0	SRBm0	SRWm0	ANDB	ANDW	MULB	ANDBI	ANDWI	MULBI	
-1	INB	LEAW1	INT1	J_W1	JNZ	LDBm1	LDWm1	SRBm1	SRWm1	ORB	ORW	IMULB	ORBI	ORWI	IMULBI	
-2	OUTB	LEAW2	INT2	J_W2	JC	LDBm2	LDWm2	SRBm2	SRWm2	EORB	EORW	DIVB	EORBI	EORWI	DIVBI	
-3	OUTB2	LEAW3	INT3	J_W3	JNC	LDBm3	LDWm3	SRBm3	SRWm3	BICB	BICW	IDIVB	BICBI	BICWI	IDIVBI	
-4	OUTBI	LEAB0	INT4	C_W0	JN	LDBm4	LDWm4	SRBm4	SRWm4	TSTB	TSTW		TSTBI	TSTWI		
-5	OUTB2I	LEAB1	INT5	C_W1	JNN	LDBm5	LDWm5	SRBm5	SRWm5	SHLB	SHLW		SHLB1	SHLW1		
-6		LEAB2	INT6	C_W2	JV	LDBm6	LDWm6	SRBm6	SRWm6	SHRB 	SHRW	MOVB	SHRB1	SHRW1	MOVBI	
-7		LEAB3	INT7	C_W3	JNV	LDBm7	LDWm7	SRBm7	SRWm7	SARB	SARW	SWPB	SARB1	SARW1		
-8		CLC	INT8		JA	POPB0	POPW0	PUSHB0	PUSHW0	RORB	RORW	MULW	INCB	INCW	MULWI	
-9		CLZ	INT9		JBE	POPB1	POPW1	PUSHB1	PUSHW1	ROLB	ROLW	IMULW	DECB	DECW	IMULWI	
-A		CLV	INT10		JGE	POPB2	POPW2	PUSHB2	PUSHW2	NOTB	NOTW	DIVW	NEGB	NEGW	DIVWI	STI
-B		CLN	INT11		JL	POPB3	POPW3	PUSHB3	PUSHW3	ADDB	ADDW	IDIVW	ADDBI	ADDWI	IDIVWI	CLI
-C		STC	INT12	RET	JGE	POPB4	POPA	PUSHB4	PUSHA	ADCB	ADCW	MOVW	ADCBI	ADCWI	MOVWI	HEVT
-D		STZ	INT13	IRET	JLE	POPB5	POPF	PUSHB5	PUSHF	SUBB	SUBW	MOVSW	SUBBI	SUBWI	MOVSI	WAIT
-E		STV	INT14	J_A	J_R	POPB6	POPPC	PUSHB6	PUSHPC	SBBB	SBBW	MOVWS	SBBBI	SBBWI		RESET
-F		STN	INT15	C_A	C_R	POPB7	DROP	PUSHB7	DUP	CMPB	CMPW	SWPW	CMPBI	CMPWI		HLT

transfer (56)
	registre => memory
	memory => registre
	memory addressing mode (8 modes : encoding 3 bits) used for transfer insruction
		000 : m0 : [ImmW]
		001 : m1 : [Wx]
		010 : m2 : [Wx + immB]
		011 : m3 : [SP + Wx]
		100 : m4 : [SP + immB]
		101 : m5 : [Wx + Wy]
		110 : m6 : [SP + Wx + immB]
		111 : m7 : [Wx + Wy + immB]

	LD	Bx [ImmW]		: LDBm0 | '00000xxx' | 'iiiiiii' | 'IIIIIIII'
	LD	Wx [ImmW]		: LDWm0 | '000000xx' | 'iiiiiii' | 'IIIIIIII'
	SR	Bx [ImmW]		: SRBm0 | '00000xxx' | 'iiiiiii' | 'IIIIIIII'
	SR	Wx [ImmW]		: SRWm0 | '000000xx' | 'iiiiiii' | 'IIIIIIII'
	LD	Bx [Wy] 		: LDBm1 | '00yy0xxx' 
	LD	Wx [Wy]			: LDWm1 | '00yy00xx'
	SR	Bx [Wy] 		: SRBm1 | '00yy0xxx'
	SR	Wx [Wy] 		: SRWm1 | '00yy00xx'
	LD	Bx [Wy + immB]		: LDBm2 | '00yy0xxx' | 'iiiiiiii'
	LD	Wx [Wy + immB]		: LDWm2 | '00yy00xx' | 'iiiiiiii'
	SR	Bx [Wy + immB]		: SRBm2 | '00yy0xxx' | 'iiiiiiii'
	SR	Wx [Wy + immB]		: SRWm2 | '00yy00xx' | 'iiiiiiii'
	LD	Bx [SP + Wy]		: LDBm3 | '00yy0xxx' 
	LD	Wx [SP + Wy]		: LDWm3 | '00yy00xx'
	SR	Bx [SP + Wy]		: SRBm3 | '00yy0xxx'
	SR	Wx [SP + Wy] 		: SRWm3 | '00yy00xx'
	LD	Bx [SP + immB]		: LDBm4 | '00yy0xxx' | 'iiiiiiii'
	LD	Wx [SP + immB]		: LDWm4 | '00yy00xx' | 'iiiiiiii'
	SR	Bx [SP + immB]		: SRBm4 | '00yy0xxx' | 'iiiiiiii'
	SR	Wx [SP + immB]		: SRWm4 | '00yy00xx' | 'iiiiiiii'
	LD	Bx [Wy + Wz]		: LDBm5 | 'yyzz0xxx' 
	LD	Wx [Wy + Wz]		: LDWm5 | 'yyzz00xx'
	SR	Bx [Wy + Wz]		: SRBm5 | 'yyzz0xxx'
	SR	Wx [Wy + Wz]		: SRWm5 | 'yyzz00xx'
	LD	Bx [SP + Wy + immB]	: LDBm6 | '00yy0xxx' | 'iiiiiiii' 
	LD	Wx [SP + Wy + immB]	: LDWm6 | '00yy00xx' | 'iiiiiiii'
	SR	Bx [SP + Wy + immB]	: SRBm6 | '00yy0xxx' | 'iiiiiiii'
	SR	Wx [SP + Wy + immB]	: SRWm6 | '00yy00xx' | 'iiiiiiii'
	LD	Bx [Wy + Wz + immB]	: LDBm7 | 'yyzz0xxx' | 'iiiiiiii' 
	LD	Wx [Wy + Wz + immB]	: LDWm7 | 'yyzz00xx' | 'iiiiiiii'
	SR	Bx [Wy + Wz + immB]	: SRBm7 | 'yyzz0xxx' | 'iiiiiiii'
	SR	Wx [Wy + Wz + immB]	: SRWm7 | 'yyzz00xx' | 'iiiiiiii'
	PUSH PC			: PUSHPC	(PC on stack, PC is address of this instruction : usefull for DO LOOP clock)
	PUSHF			: PUSHF
	PUSHA			: PUSHA	(PUSH W3,W2,W1,W0)
4	PUSH	Wx		: PUSHWxx
4	PUSH	Bx		: PUSHBxxx	(PUSH Bx in 16 bits, High byte is 0)
	DUP
	POP PC			: POPPC
	POPF			: POPF
	POPA			: POPA		(POP W0,W1,W2,W3)
4	POP	Wx		: POPWxx
4	POP	Bx		: POPBxxx	(POP w , Bx=low(w))
	DROP

register transform UAL (81)
	Byte ( 39)
		MOV	Bx By	: MOVB	| '0yyy0xxx'
		MOV	Bx immB : MOVBI | '00000xxx' | 'iiiiiiii'
		SWP	Bx By	: SWPB	| '0yyy0xxx'

		NOT	Bx	: NOTB	| '00000xxx' 
		AND	Bx By	: ANDB	| '0yyy0xxx'
		AND	Bx immB	: ANDBI | '00000xxx' | 'iiiiiiii'
		OR	Bx By	: ORB	| '0yyy0xxx'
		OR	Bx immB : ORBI	| '00000xxx' | 'iiiiiiii'
		EOR	Bx By	: EORB	| '0yyy0xxx'
		EOR	Bx immB	: EORBI	| '00000xxx' | 'iiiiiiii'
		BIC	Bx By	: BICB	| '0yyy0xxx'
		BIC	Bx immB	: BICBI	| '00000xxx' | 'iiiiiiii'
		NEG 	Bx	: NEGB	| '00000xxx'
		INC	Bx	: INCB	| '00000xxx'
		DEC	Bx	: DECB	| '00000xxx'
		ADD	Bx By	: ADDB	| '0yyy0xxx'
		ADD	Bx immB	: ADDBI	| '00000xxx' | 'iiiiiiii'
		SUB	Bx By	: SUBB	| '0yyy0xxx'
		SUB	Bx immB	: SUBBI	| '00000xxx' | 'iiiiiiii'
		ADC	Bx By	: ADCB	| '0yyy0xxx'
		ADC	Bx ImmB	: ADCBI	| '00000xxx' | 'iiiiiiii'
		SBB	Bx By	: SBBB	| '0yyy0xxx'
		SBB	Bx immB	: SBBBI	| '00000xxx' | 'iiiiiiii'
		CMP	Bx By	: CMPB	| '0yyy0xxx'
		CMP	Bx ImmB : CMPBI	| '00000xxx' | 'iiiiiiii'
		TST	Bx By	: TSTB	| '0yyy0xxx'
		TST	Bx ImmB : TSTBI	| '00000xxx' | 'iiiiiiii'
		SHL	Bx 1	: SHLB1	| '00000xxx'
		SHL	Bx By	: SHLB	| '0yyy0xxx'
		SHR	Bx 1	: SHRB1	| '00000xxx'
		SHR	Bx By	: SHRB	| '0yyy0xxx'
		SAR	Bx 1	: SARB1	| '00000xxx'
		SAR	Bx By	: SARB	| '0yyy0xxx'
		ROR	Bx 1	: RORB	| '00000xxx'	
		ROL	Bx 1	: ROLB	| '00000xxx'

		MUL	Bx By	: MULB	| '0yyy0xxx'			(Bx = Bx * By: only low(16bitsresult) is return to Bx)
		MUL	Bx immB	: MULBI	| '00000xxx'			(Bx = Bx *imm: only low(16bitsresult) is return to Bx)
		IMUL	Bx By	: IMULB	| '0yyy0xxx'			(Bx = Bx * By: only low(16bitsresult) is return to Bx)
		IMUL	Bx SimmB: IMULBI| '00000xxx' | 'siiiiiii'	(Bx = Bx *imm: only low(16bitsresult) is return to Bx)
		DIV	Bx By	: DIVB	| '0yyy0xxx'			( Bx = Bx / By )
		DIV	Bx immB : DIVBI	| '00000xxx' | 'iiiiiiii'	( Bx = Bx / immB)
		IDIV	Bx By	: IDIVB	| '0yyy0xxx'			( signed Bx = Bx / By )
		IDIV	Bx SimmB: IDIVBI| '00000xxx' | 'siiiiiii'	( signed Bx = Bx / immB)

	Word ( 42)
		MOV	Wx Wy	: MOVW	| '00yy00xx'
		MOV	Wx immW	: MOVWI	| '000000xx' | 'iiiiiiii' | 'IIIIIIII'
		MOV	SP Wx	: MOVSW	| '000000xx'
		MOV	SP immW	: MOVSI	| 'iiiiiiii' | 'IIIIIIII'
		MOV	Wx SP	: MOVWS	| '000000xx'
		SWP	Wx Wy	: SWPW	| '00yy00xx'

		NOT	Wx	: NOTW	| '000000xx'
		AND	Wx Wy	: ANDW	| '00yy00xx'
		AND	Wx immW	: ANDWI	| '000000xx' | 'iiiiiiii' | 'IIIIIIII'
		OR	Wx Wy	: ORW	| '00yy00xx'
		OR	Wx immW	: ORWI	| '000000xx' | 'iiiiiiii' | 'IIIIIIII'
		EOR	Wx Wy	: EORW	| '00yy00xx'
		EOR	Wx immW : EORWI	| '000000xx' | 'iiiiiiii' | 'IIIIIIII'
		BIC	Wx Wy	: BICW	| '00yy00xx' 
		BIC	Wx immW	: BICWI	| '000000xx' | 'iiiiiiii' | 'IIIIIIII'
		NEG 	Wx	: NEGW	| '000000xx'
		INC	Wx	: INCW	| '000000xx'
		DEC	Wx	: DECW	| '000000xx'
		ADD	Wx Wy	: ADDW	| '00yy00xx'
		ADD	Wx immW	: ADDWI	| '000000xx' | 'iiiiiiii' | 'IIIIIIII'
		SUB	Wx Wy	: SUBW	| '00yy00xx'
		SUB	Wx immW	: SUBWI	| '000000xx' | 'iiiiiiii' | 'IIIIIIII'
		ADC	Wx Wy	: ADCW	| '00yy00xx'
		ADC	Wx immW : ADCWI	| '000000xx' | 'iiiiiiii' | 'IIIIIIII'
		SBB	Wx Wy	: SBBW	| '00yy00xx'
		SBB	Wx immW	: SBBWI	| '000000xx' | 'iiiiiiii' | 'IIIIIIII'
		CMP	Wx Wy	: CMPW	| '00yy00xx' 
		CMP	Wx immW	: CMPWI	| '000000xx' | 'iiiiiiii' | 'IIIIIIII'
		TST	Wx Wy	: TSTW	| '00yy00xx'
		TST	Wx immW	: TSTWI	| '000000xx' | 'iiiiiiii' | 'IIIIIIII'
		SHL	Wx 1	: SHLW1	| '000000xx'
		SHL	Wx By	: SHLWB	| '0yyy00xx'
		SHR	Wx 1	: SHRW1	| '000000xx'
		SHR	Wx By	: SHRWB	| '0yyy00xx'
		SAR	Wx 1	: SARW1	| '000000xx'
		SAR	Wx By	: SARWB	| '0yyy00xx'
		ROR	Wx 1	: RORW	| '000000xx'
		ROL	Wx 1	: ROLW	| '000000xx'


		MUL	Wx Wy	: MULW	| '00yy00xx'				(Wx = Wx * Wy: only low(32bitsresult) is return to Wx)
		MUL	Wx immW	: MULWI	| '000000xx' | 'iiiiiiii' | 'IIIIIIII'	(Wx = Wx * imm:only low(32bitsresult) is return to Wx)
		IMUL	Wx Wy	: IMULW	| '00yy00xx'				(Wx = Wx * Wy: only low(32bitsresult) is return to Wx)
		IMUL	Wx SimmW: IMULWI| '000000xx' | 'iiiiiiii' | 'SIIIIIII'	(Wx = Wx * imm:only low(32bitsresult) is return to Wx)
		DIV	Wx Wy	: DIVW	| '00yy00xx'				( Wx = Wx / Wy )
		DIV	Wx immW : DIVWI	| '000000xx' | 'iiiiiiii' | 'IIIIIIII'	( Wx = Wx / immW)
		IDIV	Wx Wy	: IDIVW	| '00yy00xx'				( signed Wx = Wx / Wy )
		IDIV	Wx SimmB: IDIVWI| '000000xx' | 'iiiiiiii' | 'SIIIIIII'	( signed Wx = Wx / immW)
	
branching: (44)
	relative_immediate with PC = PC + SimmB, imply current PC(before PC change by branching instruction) is at next intruction.
	J	relative_immediate	: J_R | 'siiiiiii'		(PC = PC + SimmB)
	J	absolute_immediate	: J_A |	'iiiiiiii' | 'IIIIIIII'	(PC = immW )
4	J	Wx			: J_Wxx				(PC = Wx)
	C	relative_immediate	: C_R | 'siiiiiii'		(PUSH PC, PC = PC + SimmB)
	C	absolute_immediate	: C_A | 'iiiiiiii' | 'IIIIIIII'	(PUSH PC, PC = immW)
4	C	Wx			: C_Wxx				(PUSH PC, PC = Wx)
16	INT	0 to 15			: INTxxxx			(PUSH PC, PUSHF , PC = [x<<1])
	
	JE/JZ	relative_immediate	: JZ  | 'siiiiiii'		(If Z==1 then PC = PC + SimmB)
	JNE/JNZ	relative_immediate	: JNZ | 'siiiiiii'		(If Z==0 then PC = PC + SimmB)
	JC/JAE	relative_immediate	: JC  | 'siiiiiii'  		(If C==1 then PC = PC + SimmB)
	JNC/JB	relative_immediate	: JNC | 'siiiiiii'  		(If C==O then PC = PC + SimmB)
	JN/JMI	relative_immediate	: JN  | 'siiiiiii'  		(If N==1 then PC = PC + SimmB)
	JNN/JPZ	relative_immediate	: JNN | 'siiiiiii'  		(If N==0 then PC = PC + SimmB)
	JV 	relative_immediate	: JV  | 'siiiiiii'  		(If V==1 then PC = PC + SimmB)
	JNV	relative_immediate	: JNV | 'siiiiiii'  		(If V==0 then PC = PC + SimmB)
	JA	relative_immediate	: JA  | 'siiiiiii'  		(If (C==1) && (Z==0) then PC = PC + SimmB)
	JBE	relative_immediate	: JBE | 'siiiiiii'  		(If (C==0) && (Z==1) then PC = PC + SimmB)
	JGE	relative_immediate	: JGE | 'siiiiiii'  		(If N==V then PC = PC + SimmB)
	JL	relative_immediate	: JL  | 'siiiiiii'  		(If N!=V then PC = PC + SimmB)
	JG	relative_immediate	: JG  | 'siiiiiii'  		(If (Z==0) && (N==V) then PC = PC + SimmB)
	JLE	relative_immeidate	: JLE | 'siiiiiii'  		(If (Z==1) || (N!=V) then PC = PC + SimmB)

	RET				: RET				(POP PC)
	IRET				: IRET				(POPF, POP PC)

Core I/O
	IN	Bx			: INB   | '00000xxx'		(Z=([0021]==0),V=([0021]==0xFF), if Z==1 then Bx = [0020])
	OUT	Bx			: OUTB  | '00000xxx'		(Z=([0023]==0),V=([0021]==0xFF), if Z==1 then [0022]=Bx)
	OUT	immB			: OUTBI	| 'iiiiiiii'
	OUT2	Bx			: OUTB2 | '00000xxx'		(Z=([0025]==0),V=([0021]==0xFF), if Z==1 then [0024]=Bx)
	OUT2	immB			: OUTB2I| 'iiiiiiii'

Misc (23)
	NOP
	HLT
	RESET	(Hypervisor reintialize the memory(with prepared RAM content) and CPU)
	WAIT
	HEVT

	STI	(I=1)
	STC	(C=1)
	STZ	(Z=1)
	STV	(V=1)
	STN	(N=1)
	
	CLI	(I=0)
	CLC	(C=0)
	CLZ	(Z=0)
	CLV	(V=0)
	CLN	(N=0)
4	LEA	Wx SimmW  		: LEAW xx | 'iiiiiiii' | 'SIIIIIII'	(Wx = PC + SimmW) PC is at next instruction
4	LEA	Wx SimmB  		: LEAB xx | 'siiiiiii' 			(Wx = PC + SimmB) PC is at next instruction
