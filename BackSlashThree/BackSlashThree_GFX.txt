BS3 Graphic device
Maximum 160x100 8bits (1 byte color index from 0 to 255) per pixel view port (view port is what is seen on screen after REFRESH command)
Videoram : 2 x 64KiB : 2 x (256 width x 256 Height pixels)
Tile, Tile Map, Sprites (with collision pixel perfect) features available

Internally there are 2 surfaces of 256x256 pixels (2 x 64 KiB video ram)
Surface coordinates are expressed by a word (16 bits) : MSB Y coordinate (0 to 255) LSB X coordinate (0 to 255)
Only one viewport of maximum 160x100 pixels is visible on screen
Only the REFRESH command can display the current content of the viewport to the screen (except if automatic REFRESH is set on PB7 )
At any time a view port is defined by:
    surface number (wich video ram)
         0 or 1 (0 is default after RESET command)
    coordinates of top left corner of the view port in the selected surface
        16 bits : MSB Y coordinate (from 0 to 255) LSB X coordinate (from 0 to 255) (0,0 by default at RESET time)
    viewport width
        from 1 to 160 (160 is default after RESET command)
    viewport height
        from 1 to 100 (100 is default after RESET command)

Color palette:
    Each color is represented by 1 byte (8 bits) with value from 0 to 255.
    Each color index is represented by an standard color
    The BS3 GFX device use two standards : IBM 16 colors and ANSI 256 colors (256 - 16 ANSI colors).
    Color index from 0 to 15 are mapped to the IBM PC default color palette
        index   Name (IBM)      Red (0..5)	Green(0..5) Blue(0..5)  (equivalent to ANSI 256 colors Index)
        $00     Black           0           0           0           16
        $01     Blue            0           0           2           18
        $02     Green           0           2           0           28
        $03     Cyan            0           2           2           30
        $04     Red             2           0           0           88
        $05     Magenta         2           0           2           90
        $06     Brown           2           1           0           94
        $07     White           2           2           2           247 instead of 102
        $08     Gray            1           1           1           240 instead of 59
        $09     Light Blue      1           1           5           63
        $0A     Light Green     1           5           1           83
        $0B     Light Cyan      1           5           5           87
        $0C     Light Red       5           1           1           203
        $0D     Light Magenta   5           1           5           207
        $0E     Yellow          5           5           1           227
        $0F     Bright White    5           5           5           231
    Color index from 16 to 255 are mapped to ANSI terminal 256 colors palette.
    ANSI 256 colors palette integrate 216 RGB colors
      6 values of Red Green Blue (from 0 to 5)
      To compute the color index with a RGB (6 values per channel) apply this computation
      color index = 16 + (Red * 36 + Green * 6 + Blue)
      A possible conversion RGB 888 (24 bits) to ANSI RGB 216 colors can be done by mapping each channel value as follow
        from 0 to 26    : 0
        from 27 to 77   : 1
        from 78 to 128  : 2
        from 129 to 179 : 3
        from 180 to 230 : 4
        from 231 to 255 : 5
    ANSI 256 colors palette integrate 24 shades of Gray (Gray value from 0 to 23 : black to white)
      to compute the color index with Gray (24 values) apply this computation
      color index = 232 +  Gray (color index from 232 to 255)

I/O : 0120 to 0127 (height registers 8/16 bits registers )
    0120        : write         : 8 bits command
    0120        : read          : 8 bits status  : BUSY:7, WAITFORDATA:6, ENABLE:5, COMMAND_STATUS_CODE:4-0
    0121..0127  : read/write    : 8/16 bits registers : Input parameters / Output results (referenced as PB1 to PB7 for Byte value, and PW1 to PW7 for word value)
        0121 : PB1 or PW1
        0122 : PB2 or PW2
        0123 : PB3 or PW3
        0124 : PB4 or PW4
        0125 : PB5 or PW5
        0126 : PB6 or PW6
        0127 : PB7 or PW7 (PB7 reserved for auto REFRESH command)
   example : a byte write to 0121 is a write to PB1 register
             a word wrtite to 0121 is a write to PW1 register
            PW1 does not contains PB1 , it is two separated registers in the device 
            ; code to illustrate the separation of registers
            mov b0, $F4
            mov w1, $AB54
            sr  b0, [$0121] ; PB1 = $F4
            sr  w1, [$0121] ; PW1 = $AB54
            ld  b0, [$0121] ; b0 == $F4
            ld  w1, [$0121] ; w1 == $AB54 , no overlap of PB1 and PW1

If BUSY == 1 then device is busy, therefore the device can't accept any command (write on 0120) or write on PBx or PWx (x from 1 to 7)
If BUSY == 0 and WAITFORDATA == 1 then device is waiting for data reading or data writing from the bus host (e.g CPU)
if BUSY == 0 and WAITFORDATA == 1 then only RESET or END commands are accepted.
If BUSY == 0 and WAITFORDATA == 0 then device is ready to receive new command , and COMMAND_STATUS_CODE is valid indicating the status of last command
a COMMAND_STATUS_CODE equal to 0 means success, other value express an error on previous executed command
a COMMAND_STATUS_CODE == 31 means that previous command execution failed because the command code is unknown.
ENABLE bit status == 0 if no RESET command has been executing successfully or a END command has been executed successfully
ENABLE bit status == 1 gfx device is initialized (RESET command has been executed successfully)
Command starts its execution at write operation to regsiter 0120
All needed parameters has to be written to their respective register before the write to Command register (0120)

Before to request any graphical command, a RESET command must occurs before hand (executed only once before all the other commands ) and
terminated with a success status
the RESET command is like a "Enter graphical mode"
To end properly the use of the device, a command END must be performed and terminated.
The END command is like a "Leave graphical mode"

when writing 1 to PB7, it means that all COMMAND will be terminated by executing a REFRESH commmand (when command modify surface content sucessfully)
when writing 0 to PB7, it means that no automatic REFRESH command is performed after COMMAND execution.

===================================
TILES, TILE MAPS, LAYERS and SPRITES 

TILES
The GFX device has a tile mode, in order to normalize the access and use of collection of images inside a surface.
A tiles is referenced by a surface,bank number and an index.
Inside a surface we have 4 image banks
Each bank size is 256 x 64 pixels
          a Surface 256 x 256 pixels (surface 0 or 1)
+-----------------------------------------------+
|                Image bank 0                   |
|                size 256 x 64                  |
|            from (0,0) to (255,63)             |
+-----------------------------------------------+
|                Image bank 1                   |
|                size 256 x 64                  |
|            from (0,64) to (255,127)           |
+-----------------------------------------------+
|                Image bank 2                   |
|                size 256 x 64                  |
|            from (0,128) to (255,191)          |
+-----------------------------------------------+
|                Image bank 3                   |
|                size 256 x 64                  |
|            from (0,192) to (255,255)          |
+-----------------------------------------------+

Each bank can contain tiles (square image) of same size 
amongst 8x8, 16x16, 32x32 or 64x64.
Inside a bank each tile is referenced by an index.
When bank tile size is 8x8 then a bank can have 32x8 (horizontal nb tiles x vertical nb tiles in bank) = 256 tiles referenced from 0 to 255
When bank tile size is 16x16 then a bank can have 16x4 = 64 tiles referenced from 0 to 63 
When bank tile size is 32x32 then a bank can have 8x2 = 16 tiles referenced from 0 to 15
When bank tile size is 64x64 then a bank can have 4x1 = 4 tiles referenced from 0 to 3

At reset time all banks on all surfaces are configured with 8x8 size

When blitting a tile on to a target surface you may use free coordinates or tile mode coordinates
In tile mode blit target coordinates, there is a grid with a step of 8x8 pixels :
    example:
        if coordinates is $0A03
            absolute it does represent Y=$0A = 10, x=$03 = 3
            tile coordinate it represents Y=$0A x 8 = 80, y=$03 x 8 = 24 (tile coordinates to absolute coordinates conversion)

In all commands of the GFX device, when designating a surface with its bit 7=1 then it will use tile mode
    example:
        if surface is 0, in tile mode its designation is $80 (do set surface number to $80 instead of 0)
        if surface is 1, in tile mode its designation is $81 (do set surface number to $81 instead of 1)

TILE MAP 
    A tile map is a grid of tiles
    There are 2 tile maps, 32x32 (256x256 pixels surface coverage, with a grid step of 8x8 )
        tile map #0 on layer 1
        tile map #1 on layer 2 (closest)
        layer 0 is represented by the surface referenced by the view port
    A tile map may be enable/disable (visible/hidden)
    A tile map cell is defined by the following properties
        visibility : 0/1 
        image: (keycolor or OR/AND mask or copy ()) (similar as sprite)
                in key color rendering
                    : surface number 
                    : bank number
                    : index number
                    : key color 
                in mask rendering
                    OR image
                        : surface number
                        : bank number
                        : index number
                    AND image (mask)
                        : bank number (if bank == $FF then the mask is considered as only 0 (copy tile ), then index number is ignored)
                        :             (if bank == $F0 then the mask is considered as only $FF (or tile), then index number is ignored)
                        : index number (on same surface as OR image)
        Metadata : 16 bits meta data

LAYERS

   Tile map / surface / sprite layering
View port rendering is the superposed result of the layers and sprites, 
Therefore layer 2 cover layer 1 that cover layer 0

    ______________________
   /                     /  <- above layer 2 : sprites with Z = 2 
  /   Layer 2           /
 /    Tile map #1      /
/                     /___
----------------------   /  <- between layer 1 & 2 : sprites with Z = 1
  /   Layer 1           /
 /    Tile map #0      /
/                     /___
----------------------   /  <- between layer 0 & 1 : sprites with Z = 0
  /   Layer 0           /
 /    Surface          /  Surface is the one chosen by the view port configuration
/                     /
----------------------
Sprite with Z=3 is not rendered but exist as if it is rendered.
All layers are the same size (256 x 256 pixels)
The tile maps and the sprites rendering do not modify the underlying surface video ram (They are overlays)


SPRITES
    Sprites are individual picture rendered on surface but is not in its memory
    a sprites is configured with a set of properties
        image: (keycolor or OR/AND mask or copy ()) do reference to tile
                in key color rendering
                    : surface number 
                    : bank number
                    : index number
                    : key color 
                in mask rendering
                    OR image
                        : surface number
                        : bank number
                        : index number
                    AND image (mask)
                        : bank number (if bank == $FF then the mask is considered as only 0 (copy tile ), then index number is ignored)
                        :             (if bank == $F0 then the mask is considered as only $FF (or tile), then index number is ignored)
                        : index number (on same surface as OR image)
        visibility: visible/hidden
        target surface: always the same surface as the viewport
        coordinates : absolute coordinates 
        Z coordinate : 0 = between layer 0 and 1
                       1 = between layer 1 and 2
                       2 = above layer 2
        metadata : 16 bits metadata

GFX device may handle 128 sprites
If sprite A & B overlapp and are on the same Z coordinate, then if sprite index of A is < to sprite index B then B is rendered over A 
if sprite A Z value is higher than B Z value then A is rendered over B.



===================================
BS3 Gfx commands

====== GENERAL commands


>>> RESET 
Command $00
Parameter : N/A 
Description:
    Enter in graphical mode, device is reset to its default values
        Viewport size 160x100
        Viewport location in surface (x:00,y:00)
        Viewport surface number : 0
        video memory surface 0 and 1 reset to value 0 (black)
        Screen refreshed at the end of the reset command
        PB7 = 0 (no automatic REFERSH command )
Status
    COMMAND_STATUS_CODE:
        0 , reset ok
        1 , reset failed


>>> END
Command $FF
Parameter : N/a
Description:
    Leave graphical mode
Status
    COMMAND_STATUS_CODE
        0, End ok
        1, End failed (device was not reset)

>>> REFRESH
Command $01
Parameter : N/A 
Description:
    Show the viewport content to the screen
    . After you made some changes on the content of surfaces, this command will reflect the change on screen
Status
    COMMAND_STATUS_CODE
        0 End ok
        1 Device not initialized ( device was not reset)

>>> VIEWPORT_CONFIG
Command $02
Parameter :
    Input
        PB1 : surface number (0/ 1 or $80 $81)
        PW2 : top left corner Coordinates $YYXX  MSB YY: vertical coordinate, LSB XX: horizontal coordinate
                coordinate from 0 to 255
              tile coordinate if PB1 == $80 or $81  , $YYBB , MSB YY : (0..31), LSB XX (0..31)
        PW3 : view port size $HHWW : MSB HH : height (even size from 2 to 100), LSB WW : width (even size 2 to 160)
              if the size is odd then below even size is taken
    Output  
        N/A
Description:
    Configure the viewport surface number, top left corner coordinates and size (Height, width)
    Height is between 1 and 100
    Width is between 1 and 160
    if Height and Width change from previous config, a screen clear and refresh is executed after successful settings
    if Height and Width does not change from current viewport configation , then a REFRESH command is needed to see the result on screen
    if PB7 != 0 then the automatic REFRESH command is perfomed 
Status
    COMMAND_STATUS_CODE
        0 : Viewport config success
        1 : Device not initialized (device was not reset)
        2 : incorrect size (width == 0 or > 160, height == 0 or > 100) (viewport configuration unchanged)
        3 : incorrect surface number (not 0 nor 1 )
        10: incorrect tile coordinates (hapened when surface is $80 or 81 and PW2 coordinates is out of scale)

>>> VIEWPORT_GETCONFIG
Command $03
Parameter :
    Input
        N/A
    Output  
        PB1 : surface number (0: 1)
        PW2 : top left corner Coordinates $YYXX  MSB YY: vertical coordinate, LSB XX: horizontal coordinate
                coordinate from 0 to 255
        PW3 : view port size $HHWW : MSB HH : height (even size from 2 to 100), LSB WW : width (even size 2 to 160)
              if the size is odd then below even size is taken
Description:
    Get the viewport surface number, top left corner coordinates and size (Height, width)
    Height is between 1 and 100
    Width is between 1 and 160

Status
    COMMAND_STATUS_CODE
        0 : Viewport get config success
        1 : Device not initialized (device was not reset)


====== BITMAP dedicated commands : commands that modify videoram content (layer #0)

>>> VIEWPORT_CLEAR
Command $04
Parameter :
    Input
        PB1 : clear color (0 to 255)
    Output  
        N/A 
Description:
    Erase the surface and area defined by current viewport configuration with a chosen color
    Change is not reflected on screen : need a REFRESH command
    if PB7 != 0 then the automatic REFRESH command is perfomed
Status
    COMMAND_STATUS_CODE
        0 : viewport surface area cleared with chosen color 
        1 : Device not initialized (device was not reset)

>>> SURFACE_GETPIXEL
Command $05
parameter:
    Input
        PB1 : surface number (O or 1)
        PW2 : pixel coordinates ($YYXX : MSB Y coordinate, LSB X coordinate) on surface
    Output  
        PB3 : pixel color
Description
    Get the pixel color on chosen surface and coordinates
Status
    COMMAND_STATUS_CODE
        0 : pixel color retrieved (in PB3)
        1 : Device not initialized (device was not reset)
        3 : Incorrect surface number (not 0 nor 1)

>>> SURFACE_SETPIXEL
Command $06
Parameter:
    Input
        PB1 : Surface number (0 or 1)
        PW2 : pixel coordinates ($YYXX : MSB Y coordinate, LSB X coordinate) on surface
        PB3 : pixel color
    Output
        N/A 
Description 
    Set pixel color on chosen surface and coordinates. Change is not seen on screen, a REFRESH command is needed to see the change
    the change is visible (after REFRESH) if the pixel is on the same surface and inside the area of the current view port configuration.
    if PB7 != 0 then the automatic REFRESH command is perfomed
Status  
    COMMAND_STATUS_CODE
        0 : pixel color set at chosen coordinatesand surface
        1 : Device not initialized (device was not reset)
        3 : Incorrect surface number (not 0 nor 1)

>>> SURFACE_DRAW_HLINE
Command $07
Parameter
    Input
        PB1 : Surface number (0 or 1)
        PW2 : first (left most pixel of the horizontal line) pixel coordinates ($YYXX : MSB Y coordinate, LSB X coordinate) on surface
        PB3 : pixel color
        PB4 : Line length (from 1 to 255 : 0 = 256 )
    Output
        N/A
Description
    Draw a line from left to right, by providing first pixel coordinates, color and line length.
    if PB7 != 0 then the automatic REFRESH command is perfomed
Status
    COMMAND_STATUS_CODE
        0 : horizontal line drawn
        1 : Device not initialized (device was not reset)
        3 : Incorrect surface number (not 0 nor 1)

>>> SURFACE_DRAW_VLINE
Command $08
Parameter
    Input
        PB1 : Surface number (0 or 1)
        PW2 : first (top most pixel of the vertical line) pixel coordinates ($YYXX : MSB Y coordinate, LSB X coordinate) on surface
        PB3 : pixel color
        PB4 : Line length (from 1 to 255 : 0 = 256 )
    Output
        N/A
Description
    Draw a line from top to bottom, by providing first pixel coordinates, color and line length.
    if PB7 != 0 then the automatic REFRESH command is perfomed
Status
    COMMAND_STATUS_CODE
        0 : verticalline drawn
        1 : Device not initialized (device was not reset)
        3 : Incorrect surface number (not 0 nor 1)

>>> SURFACE_DRAW_BOX
Command $09
Parameter
    input
        PB1 : Surface number (0 or 1)
        PW2 : top left corder of the box coordinate ($YYXX : MSB Y coordinate, LSB X coordinate) on surface
        PB3 : pixel color
        PW4 : box size ($HHWW : MSB HH height (if 0 then 256) , LSB WW Width (if 0 then 256))
    Output
        N/A 
Description
    Draw a box with a given color, surface number, top left coordinate and a size (1 to 256) provide a 0 for a size of 256 (height or width)
    if PB7 != 0 then the automatic REFRESH command is perfomed
Status
    COMMAND_STATUS_CODE
        0 : box drawn
        1 : Device not initialized (device was not reset)
        3 : Incorrect surface number (not 0 nor 1)        

>>> SURFACE_DRAW_BOXFULL
Command $0A
Parameter
    input
        PB1 : Surface number (0 or 1)
        PW2 : top left corder of the box coordinate ($YYXX : MSB Y coordinate, LSB X coordinate) on surface
        PB3 : pixel color
        PW4 : box size ($HHWW : MSB HH height (if 0 then 256) , LSB WW Width (if 0 then 256))
    Output
        N/A 
Description
    Draw a full box with a given color, surface number, top left coordinate and a size (1 to 256) provide a 0 for a size of 256 (height or width)
    if PB7 != 0 then the automatic REFRESH command is perfomed
Status
    COMMAND_STATUS_CODE
        0 : full box drawn
        1 : Device not initialized (device was not reset)
        3 : Incorrect surface number (not 0 nor 1)        

>>> SURFACE_BLIT_OPERATOR
Command $0B
Parameter
    Input
        PB1 : Source Surface number (0 or 1, $80 or $81 for tile reference ) 
        PW2 : if PB1 == 0 or 1, Source top left corner coordinates ($YYXX : MSB Y coordinate, LSB X coordinate) on source surface
              if PB1 == $80 or $81, PW2 = $BBII  : MSB BB is bank number, LSB II is index number
        PB3 : operator between source and target (0: COPY, 1: OR, 2: EOR, 3: AND, 4: ADD, 5: SUB, 6:MUL)
        PW4 : source blit rectangle size ($HHWW : MSB HH height (if 0 then 256) , LSB WW Width (if 0 then 256))
              if PB1 == $80 or $81 then PW4 is ignored, the size is the tile size of the bank specified in PW2
        PB5 : target Surface number (0 or 1, $80 or $81 for tile 8x8 grid mapping )
        PW6 : Target top left corner coordinates 
              $YYXX : MSB Y coordinate (if PB5 == $80 or $81 then real Y = Y * 8),
                      LSB X coordinate (if PB5 == $80 or $81 then real X = X * 8) on target surface.
    Output
        N/A 
Description 
    Blit the bitmap rectangle defined by source surface, source top left corner coordinate and rectangle size,
    to the target surface at target coordinate with a chosen operation 
        0 : target = source (COPY)
        1 : target = target OR source (binary bit operation)
        2 : target = target ExclusivOr source (EOR) (binary bit operation)
        3 : target = target AND source (binary bit operation)
        4 : target = target ADD source (no cap value , may overflow)
        5 : target = target SUB source (no cap value, may underflow )
        6 : target = target MUL source (no cap value , may overflow  )
    if PB7 != 0 then the automatic REFRESH command is perfomed        
Status
    COMMAND_STATUS_CODE
        0 : Blit completed
        1 : Device not initialized (device was not reset)
        3 : Incorrect surface number (not 0 nor 1) in source and/or target
        4 : Incorrect operator (unknown operator > 6 )
        
>>> SURFACE_BLIT_KEYCOLOR
Command $0C
Parameter
    Input
        PB1 : Source Surface number (0 or 1, $80 or $81 for tile reference ) 
        PW2 : if PB1 == 0 or 1, Source top left corner coordinates ($YYXX : MSB Y coordinate, LSB X coordinate) on source surface
              if PB1 == $80 or $81, PW2 = $BBII  : MSB BB is bank number, LSB II is index number
        PB3 : Key color 
        PW4 : source blit rectangle size ($HHWW : MSB HH height (if 0 then 256) , LSB WW Width (if 0 then 256))
              if PB1 == $80 or $81 then PW4 is ignored, the size is the tile size of the bank specified in PW2
        PB5 : target Surface number (0 or 1, $80 or $81 for tile 8x8 grid mapping )
        PW6 : Target top left corner coordinates 
              $YYXX : MSB Y coordinate (if PB5 == $80 or $81 then real Y = Y * 8),
                      LSB X coordinate (if PB5 == $80 or $81 then real X = X * 8) on target surface.
    Output
        N/A 
Description 
    Blit the bitmap rectangle defined by source surface, source top left corner coordinate and rectangle size,
    to the target surface at target coordinate by respecting the key color as follow:
      if source pixel to blit == key color , then pixel is not blit (key color = transparency color)
    if PB7 != 0 then the automatic REFRESH command is perfomed

Status
    COMMAND_STATUS_CODE
        0 : Blit completed
        1 : Device not initialized (device was not reset)
        3 : Incorrect surface number (not 0 nor 1) in source and/or target
        

>>> SURFACE_BLIT_TRANSFER
Command $0D
Parameter
    Input 
        PB1 : Source Surface number (0 or 1, $80 or $81 for tile reference ) 
        PW2 : if PB1 == 0 or 1, Source top left corner coordinates ($YYXX : MSB Y coordinate, LSB X coordinate) on source surface
              if PB1 == $80 or $81, PW2 = $BBII  : MSB BB is bank number, LSB II is index number
        PW4 : source blit rectangle size ($HHWW : MSB HH height (if 0 then 256) , LSB WW Width (if 0 then 256))
              if PB1 == $80 or $81 then PW4 is ignored, the size is the tile size of the bank specified in PW2
    Output
        At any moment during the trasnfer the following registers provide current progress of bit transfer
        PW1 : current progress Y (from 0 to HH -1 ) (next write PB3 relative rectangle coordinate )
        PW5 : current progress X (from 0 to XX -1 ) (next write PB3 relative rectangle coordinate )
        PW6 : current address on selected surface   (next write PB3 surface address (coordinates))
Description
    transfer a rectangle(top left corner coordinates and size) of pixels from CPU/host to device chosen surface.
    after Command write the status BUSY bit should be 0 and WAITFORDATA must be 1
    write a byte color index on PB3 X times (X = PW4:HH * PW4:WW (if HH = 0 then HH = 256, if WW = 0 the WW == 256 ))
    Any write to PW3 will interrupt the data transfer
    Before to write to PB3 register, be sure that BUSY == 0, otherwise the write is ignored.
    the pixel stored on the surface is at progressive coordinates starting at PW2 coordinates, then progress from left to right and top to bottom
    ( respecting the size defined by PW4, current next coordinate on surface in PW6 )
    when all pixels are received, the end of transfer is indicated by WAITFORDATA == 0 and BUSY == 0
    During pixel transfer process (WAITFORDATA == 1), no new command is accepted (write COMMAND is ignored except for RESET or END) and
    write to register is forbidden except for PB3 and PW3.
        you may break the transfert by writing anything on PW3 (word write instead of byte write on PB3) or by executing a RESET or END command
    if PB7 != 0 then the automatic REFRESH command is perfomed when transfer is complete (not when trasnfer is broken)
    NB : during the transfer process BS3 GFX device modify information registers (PW6, PW5, PW1)
Status 
    BUSY == 0 and WAITFORDATA == 1 when the device is ready to receive the data
    COMMAND_STATUS_CODE when BUSY == 0 and WAITFORDATA == 0
        0 : transfer is done
        1 : Device not initialiazed (device was not reset)
        3 : incorrect surface number (not 0 nor 1)
        5 : broken data transfer (by host word write to PW3)

====== TILE, TILEMAP ans SPRITE dedicated commands

>>> TILE_BANK_CONFIG
Command $0E
Parameter
    Input
        PB1 : Surface number (0 or 1, or $80 or $81)
        PB2 : Bank number (0 ... 3) only bit 0 and 1 are interpreted, bit 2-7 are ignored
        PB3 : Size (0:8x8, 1:16x16, 2:32x32, 3:64x64) : size = 2^(PB3+3)
    Output
        N/A
Description
    Set the tile size in a tile bank in a particular surface
Status
    COMMAND_STATUS_CODE
        0 : config completed
        1 : Device not initialized (device was not reset)
        3 : Incorrect surface number (not 0 nor 1) in source and/or target    
        6 : Incorrect Bank number
        7 : Incorrect Bank Size

>>> TILE_BANK_GETCONFIG
Command $0F
Parameter
    Input
        PB1 : Surface number (0 or 1, or $80 or $81)
        PB2 : Bank number (0 ... 3) only bit 0 and 1 are interpreted, bit 2-7 are ignored
    Output
        PB3 : Size (0:8x8, 1:16x16, 2:32x32, 3:64x64) : size = 2^(PB3+3)
Description
    Get the tile size in a tile bank in a particular surface
Status
    COMMAND_STATUS_CODE
        0 : config retreived
        1 : Device not initialized (device was not reset)
        3 : Incorrect surface number (not 0 nor 1) in source and/or target    
        6 : Incorrect Bank number

>>> TILE_MAP_RESET
Command $10
Parameter   
    Input
        PB1 : Tile map number (0 or 1)
    Output
        N/a
Description
    Reset tile map to its default, all cells invisible, tile map invisible
Status
    COMMAND_STATUS_CODE
        0 : reset completed
        8 : Incorrect tile map number        
        1 : Device not initialized (device was not reset)

>>> TILE_MAP_CONFIG
Command $11
Parameter   
    Input
        PB1 : Tile map number (0 or 1)
        PB2 : visible (0 or 1)
    Output
        N/a
Description
    Configure (visibility) of a tile map, at reset time, all tile map are not visible
Status
    COMMAND_STATUS_CODE
        0 : config completed
        1 : Device not initialized (device was not reset)
        8 : Incorrect tile map number
        9 : Incorrect visibility value

>>> TILE_MAP_CELL_CONFIG
Command $12
Parameter
    Input
        PB1 : Tile map number (0 or 1)
        PW2 : Tile map cell reference coordinate $YYXX : YY MSB (0..31), XX LSB (0..31)
        PB3 : tile image Surface number (0 or 1 or $80 or $81, (bit 7 is ignored))
        PW4 : (tile ref for Or or Keycolor operation) tile image bank number and index :  $BBII  : MSB BB is bank number, LSB II is index number
        PW5 : (AND tile operation) tile image bank number and index :  $BBII  : MSB BB is bank number, LSB II is index number 
        PB5 : keyColor for tile with key color operation
        PB6 : tile type/configuration
                7 6 5 4 3 2 1 0
                | | | | | | | + 0: AND/OR operation (PB5 ignored), see bit 1 and 2 for configuration
                | | | | | | |   1: keycolor operation (PW5 ignored), bit 1 and 2 ignored
                | | | | | | |
                | | | | | | +-- 0: if bit0==0 then use PW5 tile info for AND mask, else ignored
                | | | | | |     1: if bit0==0 then special AND mask (see bit 2), else ignored
                | | | | | |
                | | | | | +---- 0: if bit0==0 and bit1==1 then all tile mask bytes are as $00(copy tile), else ignored
                | | | | |       1: if bit0==0 and bit1==1 then all tile mask bytes are as $FF(ORed tile), else ignored
                | | | | |
                | | | | +------ 0: if bit0==0 then OR tile is rendered with a OR operation, else ignored
                | | | |         1: if bit0==0 then OR tile is rendered with a XOR operation, else ignored
                | | | | 
                | | | +-------- 0: if bit0==1 then key color is used for tile rendering with transparency based on key color
                | | |           1: if bit0==1 then key color is used to render a full box in place of the tile
                | | | 
                | | +---------- reserved
                | | 
                | |
                | +------------ reserved
                |
                | 
                +-------------- 0: invisible cell map (not rendered)
                                1: visible cell map
        PW6 : custom meta data                                
    Output
        N/A 
Description 
    Configure a tile map cell.
Status
    COMMAND_STATUS_CODE
        0 : config completed
        1 : Device not initialized (device was not reset)
        3 : Incorrect surface number (not 0 nor 1) in source and/or target    
        6 : Incorrect Bank number
        8 : Incorrect Tile map number
        10: incorrect cell coordinates

>>> TILE_MAP_CELL_GETCONFIG
Command $13
Parameter
    Input
        PB1 : Tile map number (0 or 1 or $80 or $81)
        PW2 : Tile map cell reference coordinate $YYXX : YY MSB (0..31), XX LSB (0..31)
    Output
        PB3 : tile image Surface number (0 or 1)
        PW4 : (tile ref for Or or Keycolor operation) tile image bank number and index :  $BBII  : MSB BB is bank number, LSB II is index number
        PW5 : (AND tile operation) tile image bank number and index :  $BBII  : MSB BB is bank number, LSB II is index number 
        PB5 : keyColor for tile with key color operation
        PB6 : tile type/configuration
                7 6 5 4 3 2 1 0
                | | | | | | | + 0: AND/OR operation (PB5 ignored), see bit 1 and 2 for configuration
                | | | | | | |   1: keycolor operation (PW5 ignored), bit 1 and 2 ignored
                | | | | | | |
                | | | | | | +-- 0: if bit0==0 then use PW5 tile info for AND mask, else ignored
                | | | | | |     1: if bit0==0 then special AND mask (see bit 2), else ignored
                | | | | | |
                | | | | | +---- 0: if bit0==0 and bit1==1 then all tile mask bytes are as $00(copy tile), else ignored
                | | | | |       1: if bit0==0 and bit1==1 then all tile mask bytes are as $FF(ORed tile), else ignored
                | | | | |
                | | | | +------ 0: if bit0==0 then OR tile is rendered with a OR operation, else ignored
                | | | |         1: if bit0==0 then OR tile is rendered with a XOR operation, else ignored
                | | | | 
                | | | +-------- 0: if bit0==1 then key color is used for tile rendering with transparency based on key color
                | | |           1: if bit0==1 then key color is used to render a full box in place of the tile
                | | | 
                | | +---------- reserved
                | | 
                | |
                | +------------ reserved
                |
                | 
                +-------------- 0: invisible cell map (not rendered)
                                1: visible cell map
        PW6 : custom meta data                                
Description 
    Get a tile map cell configuration. Parameters with same semantic as TILE_MAP_CELL_CONFIG
Status
    COMMAND_STATUS_CODE
        0 : config retreived
        1 : Device not initialized (device was not reset)
        8 : incorrect tile map number
        10: incorrect cell coordinates


>>> SPRITE_RESET
Command $14
Parameter
    Input
        N/a
    Output
        N/A
Description
    Reset the 128 sprites configuration 
        all invisible,
Status
    COMMAND_STATUS_CODE
        0 : sprite reset completed
        1 : Device not initialized (device was not reset)

>>> SPRITE_CONFIG
Command $15
Parameter
    Input
        PB1 : Sprite number (from 0 to 128)
        PW2 : Sprite Coordinates (see bit 4 of PB6 ) $YYXX (MSB: Y coordinate, LSB: X coordinate)
        PB3 : tile image Surface number (0 or 1 or $80 or $81, (bit 7 is ignored))
        PW4 : (tile ref for Or or Keycolor operation) tile image bank number and index :  $BBII  : MSB BB is bank number, LSB II is index number
        PW5 : (AND tile operation) tile image bank number and index :  $BBII  : MSB BB is bank number, LSB II is index number (see PB6 bit 0 to 2)
        PB5 : keyColor for tile with key color operation (see PB6 bit0)
        PB6 : sprite configuration
                7 6 5 4 3 2 1 0
                | | | | | | | + 0: AND/OR operation (PB5 ignored), see bit 1 and 2 for configuration
                | | | | | | |   1: keycolor operation (PW5 ignored), bit 1 and 2 ignored
                | | | | | | |
                | | | | | | +-- 0: if bit0==0 then use PW5 tile info for AND mask, else ignored
                | | | | | |     1: if bit0==0 then special AND mask (see bit 2), else ignored
                | | | | | |
                | | | | | +---- 0: if bit0==0 and bit1==1 then all tile mask bytes are as $00(copy tile), else ignored
                | | | | |       1: if bit0==0 and bit1==1 then all tile mask bytes are as $FF(XORed tile), else ignored
                | | | | |
                | | | | +------ 0: No collision detection
                | | | |         1: Collision detect
                | | | | 
                | | | +-------- 0: PW2 represent pixel coordinates (Y=0..255, X=0..255)
                | | |           1: PW2 represent tile coordinates (Y=0..31, X=0..31)
                | | | 
                | +------------ 00 : Z = 0 sprite located between layer 0 and 1
                |               01 : Z = 1 sprite located between layer 1 and 2
                |               10 : Z = 2 sprite located above layer 2
                |               11 : Z = 3, sprite exist but rendered
                | 
                +-------------- 0: disable sprite (not rendered and ignored by the device)
                                1: enable sprite
        PW6 : custom meta data                                
    Output 
        n/A
Description
    configure a sprite 
Status
    COMMAND_STATUS_CODE
        0 : config completed
        1 : Device not initialized (device was not reset)
        3 : Incorrect surface number (not 0 nor 1) in source and/or target    
        6 : Incorrect Bank number
        12: Incorrect tile index
        8 : Incorrect Tile map number
        11: incorrect sprite number

>>> SPRITE_GETCONFIG
Command $16
Parameter
    Input
        PB1 : Sprite number (from 0 to 128)
    Output
        PW2 : Sprite Coordinates (see bit 4 of PB6 ) $YYXX (MSB: Y coordinate, LSB: X coordinate)
        PB3 : tile image Surface number (0 or 1 or $80 or $81, (bit 7 is ignored))
        PW4 : (tile ref for Or or Keycolor operation) tile image bank number and index :  $BBII  : MSB BB is bank number, LSB II is index number
        PW5 : (AND tile operation) tile image bank number and index :  $BBII  : MSB BB is bank number, LSB II is index number (see PB6 bit 0 to 3)
        PB5 : keyColor for tile with key color operation (see PB6 bit0)
        PB6 : sprite configuration
                7 6 5 4 3 2 1 0
                | | | | | | | + 0: AND/OR operation (PB5 ignored), see bit 1 and 2 for configuration
                | | | | | | |   1: keycolor operation (PW5 ignored), bit 1 and 2 ignored
                | | | | | | |
                | | | | | | +-- 0: if bit0==0 then use PW5 tile info for AND mask, else ignored
                | | | | | |     1: if bit0==0 then special AND mask (see bit 2), else ignored
                | | | | | |
                | | | | | +---- 0: if bit0==0 and bit1==1 then all tile mask bytes are as $00(copy tile), else ignored
                | | | | |       1: if bit0==0 and bit1==1 then all tile mask bytes are as $FF(ORed tile), else ignored
                | | | | |
                | | | | +------ 0: No collision detection
                | | | |         1: Collision detect
                | | | | 
                | | | +-------- 0: PW2 represent pixel coordinates (Y=0..255, X=0..255)
                | | |           1: PW2 represent tile coordinates (Y=0..31, X=0..31)
                | | | 
                | +------------ 00 : Z = 0 sprite located between layer 0 and 1
                |               01 : Z = 1 sprite located between layer 1 and 2
                |               10 : Z = 2 sprite located above layer 2
                |               11 : Z = 3, sprite exist but not rendered
                | 
                +-------------- 0: disabled sprite (not rendered and ignored by the device)
                                1: enabled sprite
        PW6 : custom meta data                                
Description
    get sprite configuration
Status
    COMMAND_STATUS_CODE
        0 : config completed
        1 : Device not initialized (device was not reset)
        11: incorrect sprite number

>>> SPRITE_COLLISION_COUNT
Command $17
parameter
    Input
        N/a
    Output
        PB1 : Number of collision (max 256)
Description
    get the number of collision between sprites
    For instance if sprite A collide sprite B (pixel perfect collision , by tile mask or computed mask if tile use keycolor)
    then there are 2 collisions : A collide B and B collide A
    collision detection is enabled if both sprite define their PB6 bit3=1
    if A collide B and C, but B and C does not collide each other, then there are 4 collisions
        A collide B
        B collide A
        A collide C 
        C collide A
Status
    COMMAND_STATUS_CODE
        0 : collision number retrieved
        1 : Device not initialized (device was not reset)
        
>>> SPRITE_GETCOLLISION
Command $18
Parameter
    Input
        PB1 : Collision number (zero based : if SPRITE_COLLISION_COUNT == 3 , here PB1 is from 0 to 2)
    Output
        PW2 : Collision from/to : $TTFF  TT: MSB to sprite number, FF:LSB from sprite number
Description
    Use SPRITE_COLLISION_COUNT before to use one or several time this GET SPRITE_COLLISION.
Status            
        0 : Collision info retrieved
        1 : Device not initialized (device was not reset)
        13: incorrect sprite collision number

