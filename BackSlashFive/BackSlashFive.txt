Light processor
16 registers 16 bits ( word )
8 execution conditions
64 Ki word addresses
16 bits per instruction ( one word per instruction)
Can be implemented for same address space for program, data and I/O
or for seperated program and data, I/O address space (no mix betwen data and program, not possible to have self modified program)

registers: - R0 to R15 (designated by 4 bits)
R0  : 0000 : general most versatile (every core instruction can use R0) (used / modified in most microprograms / mostly forbidden to be used as microprogram operand)
R1  : 0001 : general
R2  : 0010 : general
R3  : 0011 : general
R4  : 0100 : general
R5  : 0101 : general
R6  : 0110 : general
R7  : 0111 : general
R8  : 1000 : general
R9  : 1001 : general
R10 : 1010 : general
R11 : 1011 : general
R12 : 1100 :LP/BP: general or base/local pointer in stack dedicated microprograms
R13 : 1101 :SP: general or stack pointer in stack dedicated microprograms
R14 : 1110 :FL: 16 bits flags  KIHR---- -----XZC, bit 0 and 1 are reserved for C carry and Zero flag respectively
R15 : 1111 :PC: Program address
There is two set of R0 to R15 registers: one when flag K=1 (interrupt handling), 	another one when K=0 (normal execution)
K=1 and context change when flag is updated by program or by receiving an external interrupt signal (if I flag is set to 1)
when going from K=0 to K=1 all registers are switch to the interrupt handling register set: register R14 (flags) is modified with K=1, I=0 if switch occurs due to 
external context switching, I=1 if the switch occurs due to the program. 
In context when K=1, I flag a no effect (is like I is always = 0), no re-entrant interrupt possible. 
when going from K=1 to K=0 all registers are switch to the normal register set: register R14 (flags) is modified with K=0
when a switch occurs, this will cause a jump (from one R15 register to another)
As it is not possible to modify one register context from another context and both context R15 register is 0 at reset time, your code has to manage the interrupt
and non interrupt context from address 0,
From address 0 you can detect the context by testing the flag K.
In interrupt context handling (K=1) if I==1 that means the context switch due to a external interrupt signal, otherwise due to program.
When switching to context, the program continue where the last context switch occured.

flags R14:FL
   bit 0
   C : =1 if 
	addition has a carry
	substaction has a borrow
	last evacuated bit by shift left/right is 1
	=0 otherwise
   bit 1
     Z : After instruction execution if modified register/bit is equal to zero then Z=1, 0 otherwise
   bit 2
     X : custom flag to set/clear usable for conditional execution
   bit 3 to 11
     - : other general flags for program usage (bit general registers)
   bit 12
     R : =1 request a soft cpu reset, =0 default running
         CPU react only if  using  instruction "mov R14:12, x" : x=C and C==1, or x=1 
   bit 13:
     H : =1 to halt processor, =0 by default for running (once halted , no way to continue unless reset)
         CPU react only if  using  instruction "mov R14:13, x" : x=C and C==1, or x=1 
   bit 14
        if K == 0 (normal context)
           I : =1 Interrupt input signal enabled , =0 Interrupt input signal disabled(default value at reset time)
        if K == 1 (just entering into interrupt context)
           I : =0  interrupt by program, =1 interrupt by signal
   bit 15
     K : =1 Interrupt context registers, =0 normal context registers(default value at reset time)
         

Program counter R15:PC
   represent the address of the next natural instuction, not the address of current instruction in execution
   branching is typically done by a "mov R15, ..." , "add R15, ..."  instruction
   branching with "not R15..." instruction is allowed
   At processor reset time PC is set to 0 ( same for all other registers)
   
   In normal context( flag K=0), it is possible to block (get stuck) the processor by the following instruction
	al nf sub R15, 1   ; the instruction is repeated endlessly
   Interrupt signal still handled if flag I=1.
   Same instruction in interrupt context (flag K=1) get stuck forever the cpu by repeating endlessly the instruction.


Instruction structure: 16 bits (65536 possible instructions: Each value get a valid meaning )
ccc f oooo yyyy xxxx  2 registers parameters
ccc f oooo iiii iiii  1 unisgned byte parameter
ccc f oooo siii iiii  1 signed byte parameter
ccc f oooo iiii xxxx  1 register and 1 quartet parameters
ccc f oooo oooo xxxx  1 register parameter
ccc f oooo oooo iiii  1 quartet parameter

ccc       is the 3 bits of instruction execution condition
f         is the bit of conditional flag modification by instruction execution
oooo      is the 4 bits instruction code
oooo oooo is the 8 bits instruction code
xxxx      is the 4 bits register index (Rx)
yyyy      is the 4 bits register index (Ry)
iiii      is the 4 bits of an immediate unsigned integer
iiii iiii is the 8 bits of an immediate unsigned integer
siii iiii is the 8 bits of an immediate signed integer

conditions: ccc
000	al          Always executed.                          No flag tested.
001	eq or zs    Equal.                                    Z==1
010	ne or zc    Not equal.                                Z==0
011	cs or hs    Unsigned higher or same (or carry set).   C==1
100	cc or lo    Unsigned lower (or carry clear).          C==0
101 xs          custom bit set                            X==1
110 xc          custom bit clear                          X==0
111	no		    never executed (NOP)*                     No flag tested

* intruction executed but result is not written back.
  If instruction flag is fl then flags are modified.
  example: no fl sub R2, R3  ; z,c flags modified but R2 is not modified
  A no operation (nop) is doable by the combination of 'no' with 'nf'
  example: no nf sub R2, R3  ; operation executed but nothing is modified.

flag modified : f
if 0 then no flag is modified by the instruction, 1 flag(s) modified by the instruction
0	nf
1	fl

instruction: oooo / oooo oooo
raw mnemonic: 8 mnemonics
	mov, add, sub, and, or, not, shl, shr

instruction per mnemonic : 31 instructions
	mov (Z flag )
		mov Rx, 0
		mov low Rx, 0
		mov high Rx, 0
		mov Rx, Ry
		mov Rx, [Ry]
		mov [Rx], Ry
		mov low R0, imm8
		mov high R0, imm8
		mov low R0, low Rx
		mov high R0, low Rx
		mov low R0, high Rx
		mov high R0, high Rx
		mov C, Rx:imm4
		mov Rx:imm4, C
		mov Rx:imm4, 0
		mov Rx:imm4, 1

	add ( Z, C flags)
		add Rx, Ry
		add Rx, [Ry]
		add R0, imm4
		add Rx, 1
		add R15, simm8
	
	sub ( Z, C flags)
		sub Rx, Ry
		sub Rx, [Ry]
		sub R0, imm4
		sub Rx, 1

	shl ( Z, C flags)
		shl R0, imm4

	shr ( Z, C flags)
		shr R0, imm4
	
	and (Z flag)
		and R0, Rx

	or (Z flag)
		or R0, Rx
	
	not (Z flag)
		not Rx:imm4
		not Rx



Instruction encoding

=== Byte parameter (max 15 instr)
2 registers parameters 

ccc f 0000 yyyy xxxx
	mov [Rx], Ry

ccc f 0001 yyyy xxxx
	mov Rx, [Ry] 

ccc f 0010 yyyy xxxx
	add Rx, [Ry]

ccc f 0011 yyyy xxxx
	sub Rx, [Ry]

ccc f 0100 yyyy xxxx
	mov Rx, Ry

ccc f 0101 yyyy xxxx
	add Rx, Ry

ccc f 0110 yyyy xxxx
	sub Rx, Ry


1 unsigned/signed byte parameter 
ccc f 0111 iiii iiii
	mov low R0, imm8
ccc f 1000 iiii iiii
	mov high R0, imm8
ccc f 1001 siii iiii
	add R15, simm8

1 register and 1 quartet parameter
ccc f 1010 iiii xxxx
	mov C, Rx:imm4

ccc f 1011 iiii xxxx
	mov Rx:imm4, C

ccc f 1100 iiii xxxx
	mov Rx:imm4, 0

ccc f 1101 iiii xxxx
	mov Rx:imm4, 1

ccc f 1110 iiii xxxx
	not Rx:imm4

=== Quartet parameter (max 16 instr)
1 quartet
ccc f 1111 0000 iiii
	add R0, imm4

ccc f 1111 0001 iiii
	sub R0, imm4

ccc f 1111 0010 iiii
	shl R0, imm4

ccc f 1111 0011 iiii
	shr R0, imm4

1 register
ccc f 1111 0100 xxxx
	add Rx, 1

ccc f 1111 0101 xxxx
	sub Rx, 1

ccc f 1111 0110 xxxx
	mov low R0, low Rx

ccc f 1111 0111 xxxx
	mov low R0, high Rx

ccc f 1111 1000 xxxx
	mov high R0, low Rx

ccc f 1111 1001 xxxx
	mov high R0, high Rx

ccc f 1111 1010 xxxx
	mov low Rx, 0

ccc f 1111 1011 xxxx
	mov high Rx, 0

ccc f 1111 1100 xxxx
	mov Rx, 0

ccc f 1111 1101 xxxx
	not Rx

ccc f 1111 1110 xxxx
	and R0, Rx

ccc f 1111 1111 xxxx
	or  R0, Rx

==================================================================================
Assembly micro program.
The CPU understand only 31 instructions. But the assembler is completed with other instructions (macro alike)
to simulate a more extensive instruction set. Each extended instruction (microprogram) are expressed by using only the existing 
8 mnemonics.

The two first lines of each micro progam below
	ccc nf add R15, 1 
	al  nf add R15, 3 
does exist only if ccc != al.

Most micro programs below do modify register R0 

Microprograms for registry versatility
Example of missing versatility:
	  mov low R0, imm8 ; doable with core instruction set
	  mov low R1, imm8 ; undoable by a single core instruction but a sequence of several instructions.

ccc f mov low Rx, imm8  
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov low R0, imm8
	al  nf mov Rx, R0

ccc f  mov high Rx, imm8
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov high R0, imm8
	al  nf mov Rx, R0

ccc f add Rx, imm4
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  add R0, imm4
	al  nf mov Rx, R0

ccc f sub Rx, imm4
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  sub R0, imm4
	al  nf mov Rx, R0


ccc f shl Rx, imm4
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  shl R0, imm4
	al  nf mov Rx, R0

ccc f shr Rx, imm4
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  shr R0, imm4
	al  nf mov Rx, R0

ccc f mov low Rx, low Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov low R0, low Ry
	al  nf mov Rx, R0

ccc f mov low Rx, high Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov low R0, high Ry
	al  nf mov Rx, R0

ccc f mov high Rx, low Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov high R0, low Ry
	al  nf mov Rx, R0

ccc f mov high Rx, high Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov high R0, high Ry
	al  nf mov Rx, R0

ccc f and Rx, Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  and R0, Ry
	al  nf mov Rx, R0

ccc f or  Rx, Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  or R0, Ry
	al  nf mov Rx, R0

Microprogram to handle 16 bits immediate

ccc f mov Rx, imm16   ; (Rx != R0 and imm16 > 15)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov low R0, low imm6
	al  nf mov high R0, high imm16
	al  f  mov Rx, R0

ccc f mov R0, imm16   ; ( imm16 > 15 )
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  f  mov R0,R0 ;   if f=fl otherwise no instruction
or 
	ccc nf mov low R0, low imm16
	ccc nf mov high R0, high imm16
	ccc  f mov R0,R0 ;   if f=fl otherwise no instruction

ccc f add Rx, imm16   ; (Rx != R0 and imm16 > 15)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  f  add Rx, R0

ccc f sub Rx, imm16   ; (Rx != R0 and imm16 > 15)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  f  sub Rx, R0

ccc f mov Rx, [imm16] ; ( Rx can be R0 )
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov low R0, low imm6
	al  nf mov high R0, high imm16
	al  f  mov Rx, [R0]

ccc f mov [imm16], Rx ; ( Rx != R0 )
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov low R0, low imm6
	al  nf mov high R0, high imm16
	al  f  mov [R0], Rx

ccc f add Rx, [imm16] ; ( Rx != R0 )
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov low R0, low imm6
	al  nf mov high R0, high imm16
	al  f  add Rx, [R0]

ccc f sub Rx, [imm16] ; ( Rx != R0 )
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov low R0, low imm6
	al  nf mov high R0, high imm16
	al  f  sub Rx, [R0]

ccc f and Rx, imm16   ; (Rx != R0)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 4  ; if ccc != al
	al  nf mov low R0, low imm6
	al  nf mov high R0, high imm16
	al  f  and R0, Rx
	al  nf mov Rx, R0
	
ccc f or Rx, imm16    ; (Rx != R0)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 4  ; if ccc != al
	al  nf mov low R0, low imm6
	al  nf mov high R0, high imm16
	al  f  or R0, Rx
	al  nf mov Rx, R0

ccc f and Rx, [imm16] ; (Rx != R0)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 5  ; if ccc != al
	al  nf mov low R0, low imm6
	al  nf mov high R0, high imm16
	al  nf mov R0, [R0]
	al  f  and R0, Rx
	al  nf mov Rx, R0

ccc f or Rx, [imm16]  ; (Rx != R0)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 5  ; if ccc != al
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  nf mov R0, [R0]
	al  f  or R0, Rx
	al  nf mov Rx, R0

63 Microprograms to handle stack (backward memory stacking, stack addr in R13, local context in stack addr in R12)
  Push value into stack (4 microprograms)
ccc f mov STACK, Rx
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 2  ; if ccc != al
	al nf sub R13,1
	al f  mov [R13], Rx

ccc f mov STACK, [Rx]  (R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf sub R13, 1
	al  nf mov R0, [Rx]
	al  f  mov [R13], R0

ccc f mov STACK, imm16 (R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 4  ; if ccc != al
	al  nf sub R13, 1
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  f  mov [R13], R0

ccc f mov STACK, [imm16] ( R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 5  ; if ccc != al
	al  nf sub R13, 1
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  nf mov R0, [R0]
	al  f  mov [R13], R0

  Pop value from stack (3 microprograms)
ccc f mov Rx, STACK (if R15 then it is like a return from call procedure)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 2  ; if ccc != al
	al  f mov Rx, [R13]
	al  nf add R13, 1

ccc f mov [Rx], STACK ( Rx != R0, R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, [R13]
	al  nf add R13,1
	al  f mov [Rx], R0

ccc f mov [imm16], STACK (R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 11  ; if ccc != al
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
    al  nf sub R13, 1
	al  nf mov [R13],R1
	al  nf add R13, 1
	al  nf mov R1, [R13]
	al  f  mov [R0], R1
	al  nf sub R13, 1
	al  nf mov R1, [R13]
	al  nf add R13, 1
	al  nf add R13, 1

  Call procedure  (5 microprograms)
ccc f mov STACK:R15, Rx (Rx != R0 & Rx != R15)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 5  ; if ccc != al
	al  nf mov R0, R15
	al  nf add R0, 4
	al  nf sub R13, 1
	al  nf mov [R13], R0
	al  f  mov R15, Rx

ccc f mov STACK:R15, [Rx] (Rx != R0 & Rx != R15)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 5  ; if ccc != al
	al  nf mov R0, R15
	al  nf add R0, 4
	al  nf sub R13, 1
	al  nf mov [R13], R0
	al  f  mov R15, [Rx]

ccc f mov STACK:R15, imm16 (R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 7  ; if ccc != al
	al  nf mov R0, R15
	al  nf add R0, 6
	al  nf sub R13, 1
	al  nf mov [R13], R0
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  f  mov R15, R0

ccc f mov STACK:R15, [imm16] (R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 8  ; if ccc != al
	al  nf mov R0, R15
	al  nf add R0, 7
	al  nf sub R13, 1
	al  nf mov [R13], R0
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  nf mov R0, [R0]
	al  f  mov R15, R0

ccc f add STACK:R15, simm8  (near address, R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 5  ; if ccc != al
	al  nf mov R0, R15
	al  nf add R0, 4
	al  nf sub R13, 1
	al  nf mov [R13], R0
	al  f  add F15, simm8	

   Write to stack/local context (24 microprograms)
ccc f mov STACK:imm4, Rx (Rx != R0, R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, R13
	al  nf add R0, imm4
	al  f  mov [R0], Rx

ccc f mov STACK:imm4, imm16 ( R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 10  ; if ccc != al
	al  nf mov R0, R13
	al  nf add R0, imm4
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f mov STACK:imm4, [Rx] (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 9  ; if ccc != al
	al  nf mov R0, R13
	al  nf add R0, imm4
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov R0, [Rx]
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f mov STACK:imm4, [imm16] (R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 11  ; if ccc != al
	al  nf mov R0, R13
	al  nf add R0, imm4
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16	
	al  nf mov R0, [R0]
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f mov STACK:imm16, Rx (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 4  ; if ccc != al
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  nf add R0, R13
	al  f  mov [R0], Rx

ccc f mov STACK:imm16a, imm16b ( R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 11  ; if ccc != al
	al  nf mov low R0, low imm16a
	al  nf mov high R0, high imm16a
	al  nf add R0, R13
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16b
	al  nf mov high R0, high imm16b	
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f mov STACK:imm16, [Rx] (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 10  ; if ccc != al
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  nf add R0, R13
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov R0, [Rx]
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f mov STACK:imm16a, [imm16b] ( R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 12  ; if ccc != al
	al  nf mov low R0, low imm16a
	al  nf mov high R0, high imm16a
	al  nf add R0, R13
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16b
	al  nf mov high R0, high imm16b	
	al  nf mov R0, [R0]
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f mov STACK:Rx, Ry  (Rx and Ry != R15 and R0)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  nf add R0, R13
	al  f  mov [R0], Ry

ccc f mov STACK:Rx, imm16 (Rx != R0 and R15, R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 10  ; if ccc != al
	al  nf mov R0, R13
	al  nf add R0, Rx
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f mov STACK:Rx, [Ry] (Rx,Ry != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 9  ; if ccc != al
	al  nf mov R0, R13
	al  nf add R0, Rx
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov R0, [Ry]
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f mov STACK:Rx, [imm16] (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 11  ; if ccc != al
	al  nf mov R0, R13
	al  nf add R0, Rx
	al  nf sub R13, 1
	al  nf [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16	
	al  nf mov R0, [R0]
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f mov LOCAL:imm4, Rx (Rx != R0, R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, R12
	al  nf add R0, imm4
	al  f  mov [R0], Rx

ccc f mov LOCAL:imm4, imm16 ( R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 10  ; if ccc != al
	al  nf mov R0, R12
	al  nf add R0, imm4
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f mov LOCAL:imm4, [Rx] (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 9  ; if ccc != al
	al  nf mov R0, R12
	al  nf add R0, imm4
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov R0, [Rx]
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f mov LOCAL:imm4, [imm16] ( R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 11  ; if ccc != al
	al  nf mov R0, R12
	al  nf add R0, imm4
	al  nf sub R13, 1
	al  nf [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16	
	al  nf mov R0, [R0]
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f mov LOCAL:imm16, Rx (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 4  ; if ccc != al
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  nf add R0, R12
	al  f  mov [R0], Rx

ccc f mov LOCAL:imm16a, imm16b ( R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 11  ; if ccc != al
	al  nf mov low R0, low imm16a
	al  nf mov high R0, high imm16a
	al  nf add R0, R12
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16b
	al  nf mov high R0, high imm16b	
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f mov LOCAL:imm16, [Rx] (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 10  ; if ccc != al
	al  nf mov low R0, low imm16a
	al  nf mov high R0, high imm16a
	al  nf add R0, R12
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov R0, [Rx]
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f mov LOCAL:imm16a, [imm16b] ( R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 12  ; if ccc != al
	al  nf mov low R0, low imm16a
	al  nf mov high R0, high imm16a
	al  nf add R0, R12
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16b
	al  nf mov high R0, high imm16b	
	al  nf mov R0, [R0]
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f mov LOCAL:Rx, Ry  (Rx and Ry != R15 and R0)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  nf add R0, R12
	al  f  mov [R0], Ry

ccc f mov LOCAL:Rx, imm16 (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 10  ; if ccc != al
	al  nf mov R0, R12
	al  nf add R0, Rx
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f mov LOCAL:Rx, [Ry] (Rx,Ry != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 9  ; if ccc != al
	al  nf mov R0, R12
	al  nf add R0, Rx
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov R0, [Ry]
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f mov LOCAL:Rx, [imm16] (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 11  ; if ccc != al
	al  nf mov R0, R12
	al  nf add R0, Rx
	al  nf sub R13, 1
	al  nf [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16	
	al  nf mov R0, [R0]
	al  f  mov [R1], R0
	al  nf mov R1, [R13]
	al  nf add R13, 1

	Read from stack/local context (18 microprograms)
ccc f mov Rx, STACK:imm4 (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, R13
	al  nf add R0, imm4
	al  f mov Rx, [R0]

ccc f mov [Rx], STACK:imm4 (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 4  ; if ccc != al
	al  nf mov R0, R13
	al  nf add R0, imm4
	al  nf mov R0, [R0]
	al  f  mov [Rx], R0

ccc f mov [imm16], STACK:imm4 ( R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 11  ; if ccc != al
	al  nf mov R0, R13
	al  nf add R0, imm4
	al  nf mov R0, [R0]
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  f  mov [R0], R1
	al  nf mov R1,[R13]
	al  nf add R13, 1

ccc f mov Rx, STACK:imm16 (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 4  ; if ccc != al
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  nf add R0, R13
	al  f mov Rx, [R0]

ccc f mov [Rx], STACK:imm16 (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 5  ; if ccc != al
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  nf add R0, R13
	al  nf mov R0, [R0]
	al  f  mov [Rx], R0

ccc f mov [imm16a], STACK:imm16b ( R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 12  ; if ccc != al
	al  nf mov low R0, low imm16b
	al  nf mov high R0, high imm16b
	al  nf add R0, R13
	al  nf mov R0, [R0]
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16a
	al  nf mov high R0, high imm16a
	al  f  mov [R0], R1
	al  nf mov R1,[R13]
	al  nf add R13, 1

ccc f mov Rx, STACK:Ry (Rx,Ry != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 4  ; if ccc != al
	al  nf mov R0, R13
	al  nf add R0, Ry
	al  nf mov R0, [R0]
	al  f  mov Rx, R0

ccc f mov [Rx], STACK:Ry (Rx,Ry != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 4  ; if ccc != al
	al  nf mov R0, R13
	al  nf add R0, Ry
	al  nf mov R0, [R0]
	al  f  mov [Rx], R0

ccc f mov [imm16], STACK:Rx
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 11  ; if ccc != al
	al  nf mov low R0, Rx
	al  nf add R0, R13
	al  nf mov R0, [R0]
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  f  mov [R0], R1
	al  nf mov R1,[R13]
	al  nf add R13, 1

ccc f mov Rx, LOCAL:imm4 (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, R12
	al  nf add R0, imm4
	al  f mov Rx, [R0]

ccc f mov [Rx], LOCAL:imm4 (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 4  ; if ccc != al
	al  nf mov R0, R12
	al  nf add R0, imm4
	al  nf mov R0, [R0]
	al  f  mov [Rx], R0

ccc f mov [imm16], LOCAL:imm4 (R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 11  ; if ccc != al
	al  nf mov R0, R12
	al  nf add R0, imm4
	al  nf mov R0, [R0]
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  f  mov [R0], R1
	al  nf mov R1,[R13]
	al  nf add R13, 1

ccc f mov Rx, LOCAL:imm16 (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 4  ; if ccc != al
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  nf add R0, R12
	al  f mov Rx, [R0]

ccc f mov [Rx], LOCAL:imm16 (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 5  ; if ccc != al
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  nf add R0, R12
	al  nf mov R0, [R0]
	al  f  mov [Rx], R0

ccc f mov [imm16a], LOCAL:imm16b ( R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 12  ; if ccc != al
	al  nf mov low R0, low imm16b
	al  nf mov high R0, high imm16b
	al  nf add R0, R12
	al  nf mov R0, [R0]
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16a
	al  nf mov high R0, high imm16a
	al  f  mov [R0], R1
	al  nf mov R1,[R13]
	al  nf add R13, 1

ccc f mov Rx, LOCAL:Ry (Rx,Ry != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 4  ; if ccc != al
	al  nf mov R0, R12
	al  nf add R0, Ry
	al  nf mov R0, [R0]
	al  f  mov Rx, R0

ccc f mov [Rx], LOCAL:Ry (Rx,Ry != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 4  ; if ccc != al
	al  nf mov R0, R12
	al  nf add R0, Ry
	al  nf mov R0, [R0]
	al  f  mov [Rx], R0

ccc f mov [imm16], LOCAL:Rx (Rx != R0 , R0 modified)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 11  ; if ccc != al
	al  nf mov low R0, Rx
	al  nf add R0, R12
	al  nf mov R0, [R0]
	al  nf sub R13, 1
	al  nf mov [R13], R1
	al  nf mov R1, R0
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  f  mov [R0], R1
	al  nf mov R1,[R13]
	al  nf add R13, 1

	Local context / Stack context setting (2 microprograms)
ccc f mov STACK, LOCAL 
	ccc f mov R13, R12

ccc f mov LOCAL, STACK 
	ccc f mov R12, R13

	Standard instructions (add, sub, shl, shr, and, or , not) by stack (7 microprograms)
ccc f add STACK
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 4  ; if ccc != al
	al  nf mov R0, [R13]
	al  nf add R13, 1
	al   f add R0, [R13]
	al  nf mov [R13], R0

ccc f sub STACK
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 4  ; if ccc != al
	al  nf mov R0, [R13]
	al  nf add R13, 1
	al   f sub R0, [R13]
	al  nf mov [R13], R0

ccc f shl STACK, imm4
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, [13]
	al  f  shl R0, imm4
	al  nf mov [R13], R0

ccc f shr STACK, imm4
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, [13]
	al  f  shr R0, imm4
	al  nf mov [R13], R0

ccc f and STACK
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 10  ; if ccc != al
	al  nf add R13, 1
	al  nf mov R0, [R13]
	al  nf mov [R13], R1
	al  nf add R13, 1
	al  nf mov R1, [R13]
	al  f  and R0, R1
	al  nf mov [R13], R0
	al  nf sub R13, 1
	al  nf mov R1, [R13]
	al  nf add R13, 1

ccc f or STACK
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 10  ; if ccc != al
	al  nf add R13, 1
	al  nf mov R0, [R13]
	al  nf mov [R13], R1
	al  nf add R13, 1
	al  nf mov R1, [R13]
	al  f  or  R0, R1
	al  nf mov [R13], R0
	al  nf sub R13, 1
	al  nf mov R1, [R13]
	al  nf add R13, 1
	
ccc f not STACK
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf R0, [R13]
	al  f  not R0
	al  nf [R13], R0

==================================================================================
Example programs

  Example #1
  Negate a register
  input : R0
  output : R0, Z flag
  modified : R0, Z flag

	al nf not R0
	al nf add R0, 1
	al fl mov R0, R0

  Example #2
  Extend register byte value sign (R0 bit 8 to 15 = R0 bit 7)
  input : R0
  output : R0, Z
  modified: R0,R1 Z,C flags

	al nf mov C, R0:7
	al nf mov high R0, 0
        cc nf add R15, 4
	al nf mov R1, 0
	al nf not R1
	al nf mov low R1, 0
	al nf or  R0, R1
	al fl mov R0,R0

  Example #3
  Compute length of a null terminated string
  input : R1 address of the null terminated character string
  output: R2 length of the string  (R0 = 0, R3 = address of null terminated character)
  modified : R0, R3

	al nf mov R2, 0		; init found length R2 to 0
	al nf mov R3, R1        ; init start address R3 to R1
	al fl mov R0, [R3]      ; Z = [R3] == 0 ?
	zs nf add R15, 3	; if Z then end program
	al nf add R2, 1		; if not Z then increment found length (R2=R2+1)
	al nf add R3, 1		; if not Z then go to next character string address
	al nf sub R15, 5	; loop 

  Example #4
  Multiply 
  input : R1 , R2  (for R1 x R2)
  output: R3 , R4  (  R3 = low16( R1 x R2), R4 = high16( R1 x R2) )
  modified: R1, R2, R3, R4, R5 C,Z flags
	
	al nf mov R3, 0
	al nf mov R4, 0  ; R3 = R4 = R5 = 0, R4:R3 32 bits result
	al nf mov R5, 0  ; R5 used for high 16 of R1 left shift R5:R1
	al fl mov, R1, R1
	zc nf add R15, 11  ; if R1 == 0 then go endmultiply
;beginloop
	al fl mov, R2, R2
	zc nf add R15, 9  ; if R2 == 0 then go endmultiply

	al fl shr R2, 1
	cc nf add R15, 3  ; R2 >>= 1, if !C then go shift R1R5

	al fl add R3, R1 
	cs nf add R4, 1
	al nf add R4, R5 ; R4:R3 += R5:R1

; shift R1R5
	al nf shl R5, 1
	al fl shl R1, 1  
	cs nf add R5, 1 ; R5:R1 <<= 1

	al nf add R15, -11  ; loop to beginloop
;endmultiply


  Example #5
  bootstrap (template) for normal and interrupt execution (with branching if interrupt due to external signal or program)
 	org 0 ; start for normal and interrupt. at reset time
	al nf mov C, R14:15  ; C flag <= K flag
	cs nf add R15, loffset interrupt; if we'are in interrupt context go to interrupt handling
	; from here we're not in interrupt context, then long jump to start of normal code
	al nf mov low R0, low ptr normalexecution
	al nf mov high R0, high ptr normalexecution
	al nf mov R15, R0 ; long jump to the normal execution

; interupt codes : branching if it is external or program interrupt
; code below until "normalexecution" label in run under interrupt context only
interrupt:
	al nf mov C, R14:14	; C flag <= I flag
	cc nf add R15, loffset programinterrupt ; if interrupt due to program
	al nf mov low R0, low ptr externalinterrupt
	al nf mov high R0, high ptr externalinterrupt
	al nf mov R15, R0 ; long jump to the external interrupt code

programinterrupt: ; program interrupt
	... 
	... ; place here code for program interrupt
	... ; typically use shared memory addresses for
	... ; communication between interrupt code and normal code
	... 
	; end of program interrupt
	al nf mov R14:15, 0 ; end of interrupt (switch to normal context)
	; from here the code is executed when returning in interrupt context
	; long jump to "interrupt" label
	al nf mov low R0, low ptr interrupt
	al nf mov high R0, high ptr interrupt
	al nf mov R15, R0 ; long jump to the interrupt start

externalinterrupt: ; interrupt due to external signal
	... 
	... ; place here code for external signal interrupt
        ... ; typically get interrupt id from interrupt controller device
        ... ; then do the code depending of the interrupt id.
	... 
	; end of external interrupt
	al nf mov R14:15, 0; end of interrupt (switch to normal context)
	; from here the code is executed when returning in interrupt context
	; long jump to "interrupt" label
	al nf mov low R0, low ptr interrupt
	al nf mov high R0, high ptr interrupt
	al nf mov R15, R0 ; long jump to the interrupt start

; code below is run under normal context only
normalexecution:
	... 
	... ; place here normal execution code
	...
