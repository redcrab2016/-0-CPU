Light processor
16 registers 16 bits ( word )
8 execution conditions
64 Ki word addresses
16 bits per instruction ( one word per instruction)
Can be implemented for same address space for program, data and I/O
or for seperated program and data, I/O address space (no mix betwen data and program, not possible to have self modified program)

registers: - R0 to R15 (designated by 4 bits)
R0  : 0000 : general most versatile (every instruction can use R0)
R1  : 0001 : general
R2  : 0010 : general
R3  : 0011 : general
R4  : 0100 : general
R5  : 0101 : general
R6  : 0110 : general
R7  : 0111 : general
R8  : 1000 : general
R9  : 1001 : general
R10 : 1010 : general
R11 : 1011 : general
R12 : 1100 : general
R13 : 1101 : general
R14 : 1110 :FL: 16 bits flags  KIHR---- -----XZC, bit 0 and 1 are reserved for C carry and Zero flag respectively
R15 : 1111 :PC: Program address
There is two set of R0 to R15 registers: one when flag K=1 (interrupt handling), 	another one when K=0 (normal execution)
K=1 and context change when flag is updated by program or by receiving an external interrupt signal (if I flag is set to 1)
when going from K=0 to K=1 all registers are switch to the interrupt handling register set: register R14 (flags) is modified with K=1, I=0 if switch occurs due to 
external context switching, I=1 if the switch occurs due to the program. 
In context when K=1, I flag a no effect (is like I is always = 0), no re-entrant interrupt possible. 
when going from K=1 to K=0 all registers are switch to the normal register set: register R14 (flags) is modified with K=0
when a switch occurs, this will cause a jump (from one R15 register to another)
As it is not possible to modify one register context from another context and both context R15 register is 0 at reset time, your code has to manage the interrupt
and non interrupt context from address 0,
From address 0 you can detect the context by testing the flag K.
In interrupt context handling (K=1) if I==1 that means the context switch due to a external interrupt signal, otherwise due to program.
When switching to context, the program continue where the last context switch occured.

flags R14:FL
   bit 0
   C : =1 if 
	addition has a carry
	substaction has a borrow
	last evacuated bit by shift left/right is 1
	=0 otherwise
   bit 1
     Z : After instruction execution if modified register/bit is equal to zero then Z=1, 0 otherwise
   bit 2
     X : custom flag to set/clear usable for conditional execution
   bit 3 to 11
     - : other general flags for program usage (bit general registers)
   bit 12
     R : =1 request a soft cpu reset, =0 default running
         CPU react only if  using  instruction "mov R14:12, x" : x=C and C==1, or x=1 
   bit 13:
     H : =1 to halt processor, =0 by default for running (once halted , no way to continue unless reset)
         CPU react only if  using  instruction "mov R14:13, x" : x=C and C==1, or x=1 
   bit 14
        if K == 0 (normal context)
           I : =1 Interrupt input signal enabled , =0 Interrupt input signal disabled(default value at reset time)
        if K == 1 (just entering into interrupt context)
           I : =0  interrupt by program, =1 interrupt by signal
   bit 15
     K : =1 Interrupt context registers, =0 normal context registers(default value at reset time)
         

Program counter R15:PC
   represent the address of the next natural instuction, not the address of current instruction in execution
   branching is typically done by a "mov R15, ..." , "add R15, ..."  instruction
   branching with "not R15..." instruction is allowed
   At processor reset time PC is set to 0 ( same for all other registers)
   
   In normal context( flag K=0), it is possible to block (get stuck) the processor by the following instruction
	al nf sub R15, 1   ; the instruction is repeated endlessly
   Interrupt signal still handled if flag I=1.
   Same instruction in interrupt context (flag K=1) get stuck forever the cpu by repeating endlessly the instruction.


Instruction structure: 16 bits (65536 possible instruction execution: Each value get a valid meaning )
ccc f oooo yyyy xxxx  2 registers parameters
ccc f oooo iiii iiii  1 unisgned byte parameter
ccc f oooo siii iiii  1 signed byte parameter
ccc f oooo iiii xxxx  1 register and 1 quartet parameters
ccc f oooo oooo xxxx  1 register parameter
ccc f oooo oooo iiii  1 quartet parameter

ccc       is the 3 bits of instruction execution condition
f         is the bit of conditional flag modification by instruction execution
oooo      is the 4 bits instruction code
oooo oooo is the 8 bits instruction code
xxxx      is the 4 bits register index (Rx)
yyyy      is the 4 bits register index (Ry)
iiii      is the 4 bits of an immediate unsigned integer
iiii iiii is the 8 bits of an immediate unsigned integer
siii iiii is the 8 bits of an immediate signed integer

conditions: ccc
000	al      	Always executed.					No flag tested.
001	eq or zs	Equal.							Z==1
010	ne or zc	Not equal.						Z==0
011	cs or hs	Unsigned higher or same (or carry set).			C==1
100	cc or lo	Unsigned lower (or carry clear).			C==0
101     xs		custom bit set                                          X==1
110     xc              custom bit clear                                        X==0
111	no		never executed (NOP)					No flag tested

flag modified : f
if 0 then no flag is modified by the instruction, 1 flag(s) modified by the instruction
0	nf
1	fl

instruction: oooo / oooo oooo
raw mnemonic: 8 mnemonics
	mov, add, sub, and, or, not, shl, shr

instruction per mnemonic : 31 instructions
	mov (Z flag )
		mov Rx, 0
		mov low Rx, 0
		mov high Rx, 0
		mov Rx, Ry
		mov Rx, [Ry]
		mov [Rx], Ry
		mov low R0, imm8
		mov high R0, imm8
		mov low R0, low Rx
		mov high R0, low Rx
		mov low R0, high Rx
		mov high R0, high Rx
		mov C, Rx:imm4
		mov Rx:imm4, C
		mov Rx:imm4, 0
		mov Rx:imm4, 1

	add ( Z, C flags)
		add Rx, Ry
		add Rx, [Ry]
		add R0, imm4
		add Rx, 1
		add R15, simm8
	
	sub ( Z, C flags)
		sub Rx, Ry
		sub Rx, [Ry]
		sub R0, imm4
		sub Rx, 1

	shl ( Z, C flags)
		shl R0, imm4

	shr ( Z, C flags)
		shr R0, imm4
	
	and (Z flag)
		and R0, Rx

	or (Z flag)
		or R0, Rx
	
	not (Z flag)
		not Rx:imm4
		not Rx



Instruction encoding

=== Byte parameter (max 15 instr)
2 registers parameters 

ccc f 0000 yyyy xxxx
	mov [Rx], Ry

ccc f 0001 yyyy xxxx
	mov Rx, [Ry] 

ccc f 0010 yyyy xxxx
	add Rx, [Ry]

ccc f 0011 yyyy xxxx
	sub Rx, [Ry]

ccc f 0100 yyyy xxxx
	mov Rx, Ry

ccc f 0101 yyyy xxxx
	add Rx, Ry

ccc f 0110 yyyy xxxx
	sub Rx, Ry


1 unsigned/signed byte parameter 
ccc f 0111 iiii iiii
	mov low R0, imm8
ccc f 1000 iiii iiii
	mov high R0, imm8
ccc f 1001 siii iiii
	add R15, simm8

1 register and 1 quartet parameter
ccc f 1010 iiii xxxx
	mov C, Rx:imm4

ccc f 1011 iiii xxxx
	mov Rx:imm4, C

ccc f 1100 iiii xxxx
	mov Rx:imm4, 0

ccc f 1101 iiii xxxx
	mov Rx:imm4, 1

ccc f 1110 iiii xxxx
	not Rx:imm4

=== Quartet parameter (max 16 instr)
1 quartet
ccc f 1111 0000 iiii
	add R0, imm4

ccc f 1111 0001 iiii
	sub R0, imm4

ccc f 1111 0010 iiii
	shl R0, imm4

ccc f 1111 0011 iiii
	shr R0, imm4

1 register
ccc f 1111 0100 xxxx
	add Rx, 1

ccc f 1111 0101 xxxx
	sub Rx, 1

ccc f 1111 0110 xxxx
	mov low R0, low Rx

ccc f 1111 0111 xxxx
	mov low R0, high Rx

ccc f 1111 1000 xxxx
	mov high R0, low Rx

ccc f 1111 1001 xxxx
	mov high R0, high Rx

ccc f 1111 1010 xxxx
	mov low Rx, 0

ccc f 1111 1011 xxxx
	mov high Rx, 0

ccc f 1111 1100 xxxx
	mov Rx, 0

ccc f 1111 1101 xxxx
	not Rx

ccc f 1111 1110 xxxx
	and R0, Rx

ccc f 1111 1111 xxxx
	or  R0, Rx

Assembly micro program for missing register versatility (Rx with x != 0)
Example of missing versatility :
	  mov low R0, imm8 ; doable 
	  mov low R1, imm8 ; not doable by a single instruction

The two first lines of each micro progam below
	ccc nf add R15, 1 
	al  nf add R15, 3 
does exist only if ccc != al.

each micro program below do modify register R0 ( at end of each micro program R0 == Rx )

ccc f mov low Rx, imm8 
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov low R0, imm8
	al  nf mov Rx, R0

ccc f  mov high Rx, imm8
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov high R0, imm8
	al  nf mov Rx, R0

ccc f add Rx, imm4
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  add R0, imm4
	al  nf mov Rx, R0

ccc f sub Rx, imm4
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  sub R0, imm4
	al  nf mov Rx, R0


ccc f shl Rx, imm4
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  shl R0, imm4
	al  nf mov Rx, R0

ccc f shr Rx, imm4
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  shr R0, imm4
	al  nf mov Rx, R0

ccc f mov low Rx, low Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov low R0, low Ry
	al  nf mov Rx, R0

ccc f mov low Rx, high Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov low R0, high Ry
	al  nf mov Rx, R0

ccc f mov high Rx, low Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov high R0, low Ry
	al  nf mov Rx, R0

ccc f mov high Rx, high Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  mov high R0, high Ry
	al  nf mov Rx, R0

ccc f and Rx, Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  and R0, Ry
	al  nf mov Rx, R0

ccc f or  Rx, Ry
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov R0, Rx
	al  f  or R0, Ry
	al  nf mov Rx, R0

Microprogram to handle 16 bits immediate

ccc f mov Rx, imm16   ; (Rx != R0 and imm16 > 15)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov low R0, low imm6
	al  nf mov high R0, high imm16
	al  f  mov Rx, R0

ccc f mov R0, imm16   ; ( imm16 != 0 )
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  f  mov R0,R0 ;   if f=fl otherwise no instruction

ccc f add Rx, imm16   ; (Rx != R0 and imm16 > 15)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  f  add Rx, R0

ccc f sub Rx, imm16   ; (Rx != R0 and imm16 > 15)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov low R0, low imm16
	al  nf mov high R0, high imm16
	al  f  sub Rx, R0

ccc f mov Rx, [imm16] ; ( Rx can be R0 )
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov low R0, low imm6
	al  nf mov high R0, high imm16
	al  f  mov Rx, [R0]


ccc f mov [imm16], Rx ; ( Rx != R0 )
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov low R0, low imm6
	al  nf mov high R0, high imm16
	al  f  mov [R0], Rx

ccc f add Rx, [imm16] ; ( Rx != R0 )
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov low R0, low imm6
	al  nf mov high R0, high imm16
	al  f  add Rx, [R0]

ccc f sub Rx, [imm16] ; ( Rx != R0 )
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 3  ; if ccc != al
	al  nf mov low R0, low imm6
	al  nf mov high R0, high imm16
	al  f  sub Rx, [R0]

ccc f and Rx, imm16   ; (Rx != R0)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 4  ; if ccc != al
	al  nf mov low R0, low imm6
	al  nf mov high R0, high imm16
	al  f  and R0, Rx
	al  nf mov Rx, R0
	
ccc f or Rx, imm16    ; (Rx != R0)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 4  ; if ccc != al
	al  nf mov low R0, low imm6
	al  nf mov high R0, high imm16
	al  f  or R0, Rx
	al  nf mov Rx, R0

ccc f and Rx, [imm16] ; (Rx != R0)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 5  ; if ccc != al
	al  nf mov low R0, low imm6
	al  nf mov high R0, high imm16
	al  nf mov R0, [R0]
	al  f  and R0, Rx
	al  nf mov Rx, R0

ccc f or Rx, [imm16]  ; (Rx != R0)
	ccc nf add R15, 1  ; if ccc != al
	al  nf add R15, 5  ; if ccc != al
	al  nf mov low R0, low imm6
	al  nf mov high R0, high imm16
	al  nf mov R0, [R0]
	al  f  or R0, Rx
	al  nf mov Rx, R0

Example programs

  Example #1
  Negate a register
  input : R0
  output : R0, Z flag
  modified : R0, Z flag

	al nf not R0
	al nf add R0, 1
	al fl mov R0, R0

  Example #2
  Extend register byte value sign (R0 bit 8 to 15 = R0 bit 7)
  input : R0
  output : R0, Z
  modified: R0,R1 Z,C flags

	al nf mov C, R0:7
	al nf mov high R0, 0
        cc nf add R15, 4
	al nf mov R1, 0
	al nf not R1
	al nf mov low R1, 0
	al nf or  R0, R1
	al fl mov R0,R0

  Example #3
  Compute length of a null terminated string
  input : R1 address of the null terminated character string
  output: R2 length of the string  (R0 = 0, R3 = address of null terminated character)
  modified : R0, R3

	al nf mov R2, 0		; init found length R2 to 0
	al nf mov R3, R1        ; init start address R3 to R1
	al fl mov R0, [R3]      ; Z = [R3] == 0 ?
	zs nf add R15, 3	; if Z then end program
	al nf add R2, 1		; if not Z then increment found length (R2=R2+1)
	al nf add R3, 1		; if not Z then go to next character string address
	al nf sub R15, 5	; loop 

  Example #4
  Multiply 
  input : R1 , R2  (for R1 x R2)
  output: R3 , R4  (  R3 = low16( R1 x R2), R4 = high16( R1 x R2) )
  modified: R1, R2, R3, R4, R5 C,Z flags
	
	al nf mov R3, 0
	al nf mov R4, 0  ; R3 = R4 = R5 = 0, R4:R3 32 bits result
	al nf mov R5, 0  ; R5 used for high 16 of R1 left shift R5:R1
	al fl mov, R1, R1
	zc nf add R15, 11  ; if R1 == 0 then go endmultiply
;beginloop
	al fl mov, R2, R2
	zc nf add R15, 9  ; if R2 == 0 then go endmultiply

	al fl shr R2, 1
	cc nf add R15, 3  ; R2 >>= 1, if !C then go shift R1R5

	al fl add R3, R1 
	cs nf add R4, 1
	al nf add R4, R5 ; R4:R3 += R5:R1

; shift R1R5
	al nf shl R5, 1
	al fl shl R1, 1  
	cs nf add R5, 1 ; R5:R1 <<= 1

	al nf add R15, -11  ; loop to beginloop
;endmultiply


  Example #5
  bootstrap (template) for normal and interrupt execution (with branching if interrupt due to external signal or program)
 	org 0 ; start for normal and interrupt. at reset time
	al nf mov C, R14:15  ; C flag <= K flag
	cs nf add R15, byte offset interrupt; if we'are in interrupt context go to interrupt handling
	; from here we're not in interrupt context, then long jump to start of normal code
	al nf mov low R0, low offset normalexecution
	al nf mov high R0, high offset normalexecution
	al nf mov R15, R0 ; long jump to the normal execution

; interupt codes : branching if it is external or program interrupt
; code below until "normalexecution" label in run under interrupt context only
interrupt:
	al nf mov C, R14:14	; C flag <= I flag
	cc nf add R15, byte offset programinterrupt ; if interrupt due to program
	al nf mov low R0, low addr externalinterrupt
	al nf mov high R0, high addr externalinterrupt
	al nf mov R15, R0 ; long jump to the external interrupt code

programinterrupt: ; program interrupt
	... 
	... ; place here code for program interrupt
	... ; typically use shared memory addresses for
	... ; communication between interrupt code and normal code
	... 
	; end of program interrupt
	al nf mov R14:15, 0 ; end of interrupt (switch to normal context)
	; from here the code is executed when returning in interrupt context
	; long jump to "interrupt" label
	al nf mov low R0, low addr interrupt
	al nf mov high R0, high addr interrupt
	al nf mov R15, R0 ; long jump to the interrupt start

externalinterrupt: ; interrupt due to external signal
	... 
	... ; place here code for external signal interrupt
        ... ; typically get interrupt id from interrupt controller device
        ... ; then do the code depending of the interrupt id.
	... 
	; end of external interrupt
	al nf mov R14:15, 0; end of interrupt (switch to normal context)
	; from here the code is executed when returning in interrupt context
	; long jump to "interrupt" label
	al nf mov low R0, low addr interrupt
	al nf mov high R0, high addr interrupt
	al nf mov R15, R0 ; long jump to the interrupt start

; code below is run under normal context only
normalexecution:
	... 
	... ; place here normal excution code
	...


Examples macro (code template with parameter)
	; macros for stack when R13 is stack pointer, R12 as base pointer
	ccc f push Rx
		ccc nf sub R13, 1
		ccc f  mov [R13], Rx

	ccc f pop Rx
		ccc f  mov Rx, [R13]
		ccc nf add R13, 1

	ccc f drop imm4		
		ccc nf add R13, imm4

	ccc f dup
		ccc nf sub R13, 2
		ccc nf mov [R13], R0
		ccc nf add R13, 2
		ccc f mov R0, [R13]
		ccc nf sub R13, 1
		ccc nf mov [R13], R0
		ccc nf sub R13, 1
		ccc nf mov R0, [R13]
		ccc nf add R13, 1
		
	ccc f head Rx, imm4
		ccc nf mov R0, R13
		ccc nf add R0, imm4
		ccc f mov Rx, [R0]

	ccc f base Rx, imm4
		ccc nf mov R0, R12
		ccc nf add R0, imm4
		ccc f mov Rx, [R0]

	ccc f setbase 
		ccc f mov R12, R13

	ccc f call Rx
		ccc nf mov R0, R15
		ccc nf add R0, 3
		ccc nf push R0
		ccc nf mov R15, Rx
		
	ccc f ret
		ccc nf pop R0
		ccc nf mov R15, R0
