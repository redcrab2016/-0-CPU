BackslashHeight \8
Light processor inspired by BS7
16 registers 32 bits ( word )
8 execution conditions (24 with generated assembler condition)
32bits byte addresses (4GiB )
16 bits per instruction ( one word per instruction)
32 bits for instruction with large immediate

Can be implemented for same address space for program, data and I/O
or for seperated program and data, I/O address space (no mix betwen data and program, not possible to have self modified program)

registers: - R0 to R15 (designated by 4 bits)
R0  : 0000 : ALU & addressing
R1  : 0001 : ALU & addressing
R2  : 0010 : ALU & addressing
R3  : 0011 : ALU & addressing
R4  : 0100 : ALU & addressing
R5  : 0101 : ALU & addressing
R6  : 0110 : ALU & addressing
R7  : 0111 : ALU & addressing
R8  : 1000 :M0: temp value register, low word of mul/imul  : result of division for div/idiv
R9  : 1001 :M1: temp value register, high word of mul/imul : modulo result for div/idiv
R10 : 1010 :T0: temp value register
R11 : 1011 :T1: temp value register
R12 : 1100 :BP: base pointer
R13 : 1101 :SP: stack pointer
R14 : 1110 :FG: 18 bits flags  -------- ------10 KIHRds-D GLASVXZC, see below flag R14:FG for description
R15 : 1111 :PC: Program counter

There is two set of R0 to R15 registers: one when flag K=0 (Supervisor: interrupt handling),     another one when K=1 (normal execution)
K=0 and context change when flag is updated by program or by receiving an external interrupt signal (if I flag is set to 1)
when going from K=1 to K=0 all registers are switch to the interrupt handling register set: register R14 (flags) is modified with K=0, I=0 if switch occurs due to 
external context switching, I=1 if the switch occurs due to the program. 
In context when K=0, I flag a no effect (is like I is always = 0), no re-entrant interrupt possible. 
when going from K=0 to K=1 all registers are switch to the normal register set: register R14 (flags) is modified with K=1
when a switch occurs, this will cause a jump (from one R15 register to another)
As it is not possible to modify one register context from another context and both context R15 register is 0 at reset time, your code has to manage the interrupt
and non interrupt context from address 0,
From address 0 you can detect the context by testing the flag K.
In interrupt context handling (K=0) if I==1 that means the context switch due to a external interrupt signal, otherwise due to program.
When switching to context, the program continue where the last context switch occured.

flags R14:FG
   bit 0
     C : =1 if 
    addition has a carry
    substaction has a borrow
    last evacuated bit by shift left/right is 1
    =0 otherwise
   bit 1
     Z : After instruction execution if register or bit size result is equal to zero then Z=1, 0 otherwise
   bit 2
     X : custom flag to set/clear usable for conditional execution
   bit 3
     V : overflow flag , set to 1 if signed addition or signed substraction is overflow or multiply result need more than 16 bits, 0 otherwise.
   bit 4
     S : Sign flag, set to 1 if result is negative (S= most significant bit result),0 if positive
   bit 5
     A : computed flag: result of bit flag algebra C==1 && Z==0 
        1:  "is above" "is higher" unsigned
        0:  "is below or equal" "is lower or same" unsigned
   bit 6
     L : computed flag: result of bit flag algebra S!=V,  
        1: "is less" (signed integer comparison)
        0: "is greater or equal"
   bit 7
     G : computed flag: result of bit flag algebra Z==0 && S==V, 
        1: "is greater" (signed integer comparison)
        0: "is less or equal"
   bit 8
     D : divide by zero error
        1: last division operation tried to divide by zero
        0: last division operation was ok        
   bit 9
     - : general flag for program usage (bit general register)
   bit 10
     s : Register file to use as source for next operation "mov Rx, Ry" (for Ry)
         by default s=K
         after next operation "mov Rx, Ry" 's' is set to its default value
         0: use interrupt handling(supervisor) context register file
         1: use normal context register file
   bit 11
     d : Register file to use as destination for next operation "mov Rx, Ry" (for Rx)
         by default d=K
         after next operation "mov Rx, Ry" 'd' is set to its default value
         0: use interrupt handling context register file
         1: use normal context register file
   bit 12
     R : =1 request a soft cpu reset, =0 default running
   bit 13:
     H : =1 to halt processor, =0 by default for running (once halted , no way to continue unless reset)
   bit 14
        if K == 1 (normal context)
           I : =1 Interrupt input signal enabled , =0 Interrupt input signal disabled(default value at reset time)
        if K == 0  (just entering into interrupt/supervisor context)
           I : =0  interrupt by program, =1 interrupt by signal
   bit 15
     K : =0 supervisor/Interrupt context registers, =1 normal context registers(default value at reset time)
   bit 16
     0 : always 0, can't be modified
   bit 17
     1 : always 1, can't be modified   

Program counter R15:PC
   represent the address of the next natural instuction, not the address of current instruction in execution
   branching is typically done by a "mov R15, ..." , "add R15, ..."  instruction
   branching with "not R15..." instruction is allowed
   At processor reset time PC is set to 0 ( same for all other registers, in all contexts)
   
   In normal context( flag K=1), it is possible to block (get stuck) the processor by the following instruction
    al nf sub R15, 1   ; the instruction is repeated endlessly
   Interrupt signal still handled if flag I=1.
   Same instruction in interrupt context (flag K=0) get stuck forever the cpu by repeating endlessly the instruction.

mnemonics : mov, add, sub , and, or , xor, not, shl, shr, sar, mul, div, imul, idiv, neg, push, pop, call, ret, wait , reset, swsuper, swuser, cli, sti, srcsuper, srcuser, dstsuper, dstuser, 

Instruction structure: 16 bits 
ccc f ooo iiiii xxxx  1 register and 5 bits immediates
      000 mov X, Rx:Imm5  (flag X is assign with the value of bit imm4 of register Rx)
      001 mov Rx:Imm5, X  (The value of bit imm4 of register Rx is assign with the value of flag X)
ccc f oooo iiiii xxx 1 register from R0 to R7 and 5 bits immediate
      0100 shl Rx, Imm5
      0101 shr Rx, Imm5
      0110 sar Rx, Imm5
ccc f oooo yyyy xxxx  2 registers parameters
      0111 mov Rx, Ry
mmmm  ooooo yyy xxxx  2 registers parameters (Rx from R0 to R15, Ry R0 to R7)
0000  10000 mov Rx, byte [Ry]  
0001  10000 mov Rx, byte [Ry++]    , after memory access Ry = Ry + 1 
0010  10000 mov Rx, byte [R12 + Ry]  
0011  10000 mov Rx, byte [Ry--]  , after memory access Ry = Ry - 1 
0100  10000 mov low Rx, hword [Ry]  
0101  10000 mov low Rx, hword [Ry++] , after memory access Ry = Ry + 2   
0110  10000 mov low Rx, hword [R12 + Ry shl 1]  
0111  10000 mov low Rx, hword [Ry--] , after memory access Ry = Ry - 2 
1000  10000 mov high Rx, hword [Ry]  
1001  10000 mov high Rx, hword [Ry++]  , after memory access Ry = Ry + 2 
1010  10000 mov high Rx, hword [R12 + Ry shl 2]  
1011  10000 mov high Rx, hword [Ry--]  , after memory access Ry = Ry - 2 
1100  10000 mov Rx, word [Ry]  
1101  10000 mov Rx, word [Ry++] , after memory access Ry = Ry + 4 
1110  10000 mov Rx, word [R12 + Ry shl 2]  
1111  10000 mov Rx, word [Ry--]  , after memory access Ry = Ry - 4
mmmm  ooooo yyyy xxx  2 registers parameters (Rx from R0 to R7 and Ry from R0 to R15)
0000  10001 mov byte [Rx], Ry  
0001  10001 mov byte [Rx++], Ry  
0010  10001 mov byte [R12 + Rx shl 2], Ry  
0011  10001 mov byte [Rx--], Ry  
0100  10001 mov hword [Rx], low Ry  
0101  10001 mov hword [Rx++], low Ry  
0110  10001 mov hword [R12 + Rx shl 2], low Ry  
0111  10001 mov hword [Rx--], low Ry  
1000  10001 mov hword [Rx], high Ry  
1001  10001 mov hword [Rx++], high Ry  
1010  10001 mov hword [R12 + Rx shl 2], high Ry  
1011  10001 mov hword [Rx--], high Ry  
1100  10001 mov word [Rx], Ry  
1101  10001 mov word [Rx++], Ry  
1110  10001 mov word [R12 + Rx shl 2], Ry  
1111  10001 mov word [Rx--], Ry  
ccc f oooooo yyy xxx  2 registers parameters (from R0 to R7)
      100100 add Rx, Ry
      100101 sub Rx, Ry   if ccc=no then "sub" is "cmp"
      100110 and Rx, Ry   if ccc=no then "and" is "tst"
      100111 or  Rx, Ry
      101000 xor Rx, Ry
      101001 shl Rx, Ry
      101010 shr Rx, Ry
      101011 sar Rx, Ry
      101100 mul Rx, Ry  
      101101 div Rx, Ry  
      101110 imul Rx, Ry 
      101111 idiv Rx, Ry 
ccc f oooooooo  xxxx  1 register parameter
      11000000 add Rx, 1  or inc Rx
      11000001 add Rx, 2 
      11000010 add Rx, 4
      11000011 neg Rx
      11000100 sub Rx, 1 or dec Rx
      11000101 sub Rx, 2
      11000110 sub Rx, 4
      11000111 not Rx
      11001000 push Rx
      11001001 pop Rx
      11001010 call Rx
ccc f oooooooo  xxxx iiiiiiiiiiiiiiii 1 register parameter, 16 bits immediate (R14, R15 forbidden: undefined behavior)
      11001011 mov low Rx, imm16
      11001100 mov high Rx, imm16
ccc f oooooooooooo siiiiiiiiiiiiiii 16 bits signed immediate
      110011010000 call simm16,  relative call
      110011010001 add R15, simm16  or jmp simm16 , relative jump
ccc f oooooooooooo
      110011010010 ret 
      110011010011 wait
      110011010100 swsuper
      110011010101 swuser
      110011010110 cli  (clear I flag)
      110011010111 sli  (set I flag)
      110011011000 srcsuper  (clear s flag)
      110011011001 srcuser   (set s flag)
      110011011010 dstsuper (clear d flag)
      110011011011 dstuser  (set d flag)

(...) undefined
      1100________  reserved for floating point math on stack

      111111111110 halt
      111111111111 reset

ccc       is the 3 bits of instruction execution condition
f         is the bit of conditional flag modification by instruction execution
mmmm      is the 4 bits for addressing mode
ooo       is the 3 bits instruction code
oooo      is the 4 bits instruction code
ooooo     is the 5 bits instruction code
oooooo    is the 6 bits instruction code
oooooooo  is the 8 bits instruction code
xxxx      is the 4 bits register index (Rx) from R0 to R15
yyyy      is the 4 bits register index (Ry) from R0 to R15
xxx       is the 3 bits register index (Rx) from R0 to R7 or [R8] to [R13]
yyy       is the 3 bits register index (Ry) from R0 to R7 or [R8] to [R13]
iiiii     is the 5 bits of an immediate unsigned integer
ii...ii   is the 16 bits of an immediate unsigned integer
si...ii   is the 16 bits of an immediate signed integer

addressing mode: mmmm
  data size access 
    00mm : byte access
    01mm : half word access from/to low register part (less significant half word)
    10mm : half word access from/to high register part (most significant half word)
    11mm : word access
  adressing 
    mm00 : address by register
    mm01 : address by register then increment the register by data size in byte
    mm10 : base pointer (R12) + register left shifted by 2 
    mm11 : address by register then decrement the register by data size in byte

conditions: ccc
000    al          Always executed.                          No flag tested.
001    eq or zs    Equal.                                    Z==1, Z flag is set
010    ne or zc    Not equal.                                Z==0, Z flag is cleared
011    cs or hs    Unsigned higher or same (or carry set).   C==1, C flag is set
100    cc or lo    Unsigned lower (or carry clear).          C==0, C flag is cleared
101    xs          custom bit set                            X==1, X flag is set
110    xc          custom bit clear                          X==0, X flag is cleared
111    no          no result *                               No flag tested

* intruction executed (same as 'al') but result is not written back.
  If instruction flag is fl then flags are modified.
  example: no fl sub R2, R3  ; z,c,s,v flags modified but R2 is not modified
  A no operation (nop) is doable by the combination of 'no' with 'nf'
  example: no nf sub R2, R3  ; operation executed but nothing is modified.

The assembler have to know other conditions that generate an additional move bit instruction before, 
and change the condition to xs or xc (depending the case)
for instance:
    pl nf sub R1, R2 ;( if S==0 then R1=R1-R2, and do not modify the flags) : can't be assembled in one word
is assembled as
    al nf mov X, R14:4  ;(X flag = S flag)
    xc nf sub R1, R2 ;(if X==0 then R1=R1-R2, and do not modify the flags) : assembled in two words
another example:
    mi nf add R1, R2
is assembled as    
    al nf mov X, R14:4
    xs nf add R1, R2    
The additional conditions and encoding is as following ( 10 additional conditions )
(f is modified flag (fl or nf), ope is the operation to execute under condition (One of the 31 core instructions))
hi,as : Higher (unsigned) flag register bit 5, A flag is set
  instruction
    hi f ope
  become 
    al nf mov x, R14:5
    xs f ope
ls,ac : Less or same (unsigned) not flag register bit 5, A flag is cleared
  instruction 
    ls f ope
  become
    al nf mov x, R14:5
    xc f ope
ge,lc : is greater or equal (signed) not flag register bit 6, L flag is cleared
  instruction
    ge f ope
  become
    al nf mov x, R14:6
    xc f ope
lt,ll : is less (signed) flag register bit 6, L flag is set
  instruction
    lt f ope
  become
    al nf mov x, R14:6
    xs f ope
gt,gs : is greater (signed) flag register bit 7, G flag is set
  instruction
    gt f ope
  become
    al nf mov x, R14:7
    xs f ope
le,gc : is less or equal (signed) not flag register 7, G flag is cleared
  instruction
    le f ope
  become 
    al nf mov x, R14:7
    xc f ope
vc : no overflow (signed) flag register 3, V flag is cleared
  instruction
    vc f ope
  become 
    al nf mov x, R14:3
    xc f ope
vs : overflow (signed) flag register 3, V flag is set
  instruction
    vs f ope
  become 
    al nf mov x, R14:3
    xs f ope
pl, sc : is positive (signed) flag register 4, S flag is cleared
  instruction
    pl f ope
  become
    al nf mov x, R14:4
    xc f ope
mi, ss : is negative (signed) flag register 4, S flag is set
  instruction
    mi f ope
  become
    al nf mov x, R14:4
    xs f ope
dz, ds : division by zero error, D flag is set
  instruction
    dz f ope
  become
    al nf mov x, R14:8
    xs f ope
dc : no division error, D flag is cleared
  instruction
    dc f ope
  become
    al nf mov x, R14:8
    xc f ope
is : interruption is enable(in normal context K=0) / interrupt by signal(in context K=1)
  instruction
    is f ope
  become
    al nf mov x, R14:14
    xs f ope

ic : interruption is disable/lock (in normal context K=0) / interrupt by program(in context K=1)
  instruction
    is f ope
  become
    al nf mov x, R14:14
    xc f ope

ks : in context of interruption handling
  instruction
    ks f ope
  become
    al nf mov x, R14:15
    xs f ope

kc : in normal context
  instruction
    kc f ope
  become
    al nf mov x, R14:15
    xc f ope

flag modified : f
if 0 then no flag is modified by the instruction, 1 flag(s) modified by the instruction
0    nf
1    fl


